\chapter{Teori Skema Holland}

\section{Apa itu Skema?}
Skema adalah template formal yang didefinisikan di atas alfabet $\{0,1,*\}$. Untuk panjang string tetap $l$, sebuah skema
\[ H \in \{0,1,*\}^l \]
menentukan nilai yang dibutuhkan pada beberapa lokus dan membiarkan lokus lain tidak ditentukan (simbol "don't care"). Misalkan $\Sigma = \{0,1\}$ dan $\Sigma^l$ himpunan semua string biner panjang-$l$. Kita mengatakan sebuah string konkret $s\in\Sigma^l$ memenuhi skema $H$ (tulis $s\in[H]$) jika setiap posisi yang terdefinisi pada $H$ cocok dengan $s$:
\begin{equation}
 s \in [H] \quad:\!\Leftrightarrow\quad \forall i\in\{1,\dots,l\},\; H_i \neq * \Rightarrow s_i = H_i.
\end{equation}

Himpunan $[H] = \{s\in\Sigma^l : s\text{ matches }H\}$ adalah kelas ekivalen genom konkret yang direpresentasikan oleh $H$. Jika $k(H)$ menyatakan jumlah simbol don't-care pada $H$ (jadi $k(H)=|\{i:\;H_i=*\}|$), maka kardinalitas kelas ini adalah
\begin{equation}
 |[H]| = 2^{k(H)}.
\end{equation}

Dua kuantitas lain yang sering dipakai adalah orde dan panjang pendefinisian. Orde $o(H)$ sama dengan jumlah posisi yang tetap (simbol bukan-*), jadi $o(H)=l-k(H)$. Jika $i_{\min}$ dan $i_{\max}$ adalah indeks posisi tetap pertama dan terakhir pada $H$, panjang pendefinisian didefinisikan sebagai
\begin{equation}
 \delta(H) = i_{\max} - i_{\min}.
\end{equation}

Contoh: untuk $H=1*0*1$ dengan $l=5$ kita memiliki posisi tetap di indeks $1,3,5$, $k(H)=2$, $o(H)=3$, dan
\[ |[H]|=2^{2}=4, \qquad \delta(H)=5-1=4,\]
dengan string yang cocok \{10001,10011,11001,11011\}.

\subsection{Properti Skema}

\subsubsection{Orde Skema}
Orde $o(H)$ adalah jumlah posisi tetap (simbol bukan-*):
\begin{equation}
 o(H) = \text{jumlah bit terdefinisi pada } H
\end{equation}

Untuk $H = 1*0*1$: $o(H) = 3$

\subsubsection{Panjang Pendefinisian}
Panjang pendefinisian $\delta(H)$ mengukur rentang antara posisi tetap pertama dan terakhir pada pola.  Secara formal dihitung sebagai selisih indeks antara posisi tetap terakhir dan pertama:
\begin{equation}
 \delta(H) = \text{posisi tetap terakhir} - \text{posisi tetap pertama}
\end{equation}

Panjang pendefinisian kecil berarti bit tetap skema berkumpul rapat.
Signifikansi praktis panjang pendefinisian terkait erat dengan pandangan blok-bangunan dalam GA: blok gen pendek yang saling terhubung yang memberi fitness di atas rata-rata.

Untuk $H = 1*0*1$: $\delta(H) = 5 - 1 = 4$

\textbf{Contoh dari Buku Ajar:}
\begin{itemize}
    \item $S_1 = (* * * 0 0 1 * 1 1 0)$: $\delta(S_1) = 10 - 4 = 6$
    \item $S_2 = (* * * * 0 0 * * 0 *)$: $\delta(S_2) = 9 - 5 = 4$
    \item $S_3 = (1 1 1 0 1 * * 0 0 1)$: $\delta(S_3) = 10 - 1 = 9$
\end{itemize}

\subsection{Teorema Skema (Teorema Fundamental)}
Teorema skema menjelaskan bagaimana jumlah harapan string yang memenuhi sebuah skema berubah dari satu generasi ke generasi berikutnya.


\subsubsection{Teorema Skema Gabungan}
Menggabungkan semua pengaruh:
\begin{equation}
 E[m(H,t+1)] \geq m(H,t) \cdot \frac{f(H)}{\bar{f}} \cdot \left(1 - p_c \cdot \frac{\delta(H)}{l-1}\right) \cdot (1 - p_m)^{o(H)}
\end{equation}

\subsection{Hipotesis Blok-Bangunan}
Hipotesis blok-bangunan dapat dinyatakan secara tepat menggunakan formalismo skema Holland: sebuah blok-bangunan adalah skema $H$ dengan panjang pendefinisian kecil $\delta(H)$, orde rendah $o(H)$, dan fitness di atas rata-rata $f(H) > \bar f$. Teorema skema memberi kriteria kuantitatif agar skema tersebut tumbuh dalam ekspektasi dari generasi $t$ ke $t+1$:
\begin{equation}
 E[m(H,t+1)] \ge m(H,t) \cdot \frac{f(H)}{\bar f} \cdot \left(1 - p_c\frac{\delta(H)}{l-1}\right) \cdot (1-p_m)^{o(H)}.
\end{equation}

Dengan demikian, kondisi yang diperlukan (tetapi tidak cukup) agar $H$ tumbuh secara harapan adalah faktor multiplikatif di ruas kanan melebihi satu. Menyusun ulang memberi kondisi ambang informal
\begin{equation}
 \frac{f(H)}{\bar f} > \frac{1}{\left(1 - p_c\frac{\delta(H)}{l-1}\right) (1-p_m)^{o(H)}}.
\end{equation}

Ketidaksamaan ini memperjelas trade-off: fitness relatif lebih tinggi, panjang pendefinisian lebih kecil, dan orde lebih rendah meningkatkan peluang sebuah skema berkembang.

\section{Paralelisme Implisit}
GA bekerja pada populasi genom konkret, tetapi setiap genom konkret secara simultan menginstansiasi keluarga skema yang jumlahnya eksponensial. Secara konkret, untuk string biner panjang $l$ ada $3^l$ skema yang mungkin (setiap posisi bisa 0, 1, atau "don't care"). Satu string panjang-$l$ cocok dengan tepat $2^l$ skema berbeda karena setiap lokus bisa dibiarkan tetap atau diganti simbol don't-care. Akibatnya, populasi berukuran $n$ menyediakan contoh langsung paling banyak $n2^l$ skema (menghitung multiplikitas), dan—mengabaikan tumpang tindih antar individu—angka ini bisa eksponensial besar terhadap $l$. Fakta kombinatorial ini mendasari gagasan intuitif bahwa GA mengevaluasi banyak skema secara paralel.

Perhitungan yang lebih rinci mengelompokkan skema menurut orde mereka (jumlah lokus tetap). Jumlah skema orde $r$ adalah
\begin{equation}
 \binom{l}{r}2^{r},
\end{equation}
karena dipilih $r$ lokus yang tetap lalu diberi bit (0 atau 1) pada setiap lokus tetap. Jumlah skema yang orde-nya tidak melebihi $k$ adalah
\begin{equation}
 S_k = \sum_{r=0}^k \binom{l}{r}2^{r},
\end{equation}
yang, untuk $k$ kecil tetap, tumbuh secara polinomial terhadap $l$ (derajat $k$) bukan eksponensial. 



\section{Implikasi Praktis}

% Subsection on encoding/representation removed per user request.

\subsection{Pemilihan Operator dan Parameter}
Pertimbangan berdasarkan skema menunjukkan trade-off tertentu saat memilih operator dan parameternya:
\begin{itemize}
    \item \textbf{Ukuran populasi ($n$):} Populasi lebih besar mengurangi noise sampling dan meningkatkan probabilitas keberadaan skema orde-rendah yang berguna dalam multiplicity yang cukup. Gunakan aturan ukuran populasi atau eksperimen untuk memastikan sampling andal.
\end{itemize}

\subsection{Pemantauan dan Diagnostik Praktis}
Untuk menerapkan desain yang diinformasikan skema dalam praktik, pantau statistik populasi secara berkala:
\begin{itemize}
    \item Lacak keberagaman genotip (mis. frekuensi alel per-lokus) dan varians fenotip untuk mendeteksi konvergensi prematur.
    \item Hitung hitungan skema sederhana atau sampling skema kandidat untuk memverifikasi apakah blok-bangunan yang diharapkan ditemukan dan dipertahankan.
\end{itemize}

\section{Keterbatasan Teori Skema}

Teori skema memberikan kerangka konseptual dan analitik yang bernilai, tetapi asumsi dan cakupannya menimbulkan keterbatasan penting yang harus dikenali praktisi.

\subsection{Ekspektasi vs dinamika populasi terbatas}
Pernyataan aljabar inti dari teori skema adalah pernyataan tentang ekspektasi. Pada populasi terbatas, noise sampling stokastik, genetic drift, dan galat sampling dapat menyebabkan dinamika realisasi menyimpang jauh dari ekspektasi. Oleh karena itu prediksi berbasis skema harus ditafsirkan sebagai kecenderungan, bukan hasil deterministik.

\subsection{Penanganan epistasis dan interaksi kompleks terbatas}
Teori skema paling informatif untuk pola orde-rendah dan panjang-pendefinisian pendek. Ketika fitness muncul dari interaksi orde-tinggi (epistasis kuat) atau dari dependensi terdistribusi yang kompleks antar lokus, hitungan skema mengaburkan struktur relevan dan menawarkan daya prediksi yang terbatas.

\subsection{Pembatasan pada alfabet sederhana dan enkoding panjang tetap}
Analisis skema klasik mengasumsikan alfabet biner dan string panjang tetap. Perlu reformulasi hati-hati untuk alfabet yang lebih kaya, genom ber- panjang variabel, atau enkoding tidak langsung; penerapan intuisi berbasis biner secara naif dapat menyesatkan.


\subsection{Protokol empiris yang direkomendasikan}
Saat menggunakan penalaran berbasis skema untuk membimbing desain algoritma, ikuti protokol empiris yang mengurangi risiko kesimpulan yang keliru:
\begin{itemize}
    \item Jalankan beberapa percobaan independen dan laporkan varians, bukan hanya rata-rata performa.
    \item Jika memungkinkan, visualisasikan lintasan frekuensi alel dan plot unitation per-blok untuk mendiagnosis kapan dan di mana skema berguna hilang atau dipertahankan.
\end{itemize}

\section{Teorema No Free Lunch}
Menyatakan bahwa tidak ada algoritma yang unggul di seluruh kemungkinan masalah.


