\chapter{GA Cycle and Holland Schema Theory}

\section{The Genetic Algorithm Cycle}
The genetic algorithm follows a cyclic process that mimics natural evolution. Understanding this cycle is crucial for implementing and analyzing GA performance.

\subsection{Detailed GA Cycle}

\begin{figure}[H]
\centering
\begin{tikzpicture}[node distance=2cm, auto]
    % Define styles
    \tikzstyle{process} = [rectangle, minimum width=3cm, minimum height=1cm, text centered, draw=black, fill=blue!20]
    \tikzstyle{decision} = [diamond, minimum width=3cm, minimum height=1cm, text centered, draw=black, fill=green!20]
    \tikzstyle{arrow} = [thick,->,>=stealth]
    
    % Nodes
    \node [process] (init) {Initialize Population};
    \node [process, below of=init] (eval) {Evaluate Fitness};
    \node [decision, below of=eval] (term) {Termination?};
    \node [process, below of=term, yshift=-1cm] (select) {Selection};
    \node [process, below of=select] (cross) {Crossover};
    \node [process, below of=cross] (mutate) {Mutation};
    \node [process, right of=mutate, xshift=3cm] (replace) {Replacement};
    \node [process] (output) at (6,-1) {Output Best};
    
    % Arrows
    \draw [arrow] (init) -- (eval);
    \draw [arrow] (eval) -- (term);
    \draw [arrow] (term) -- node {No} (select);
    \draw [arrow] (select) -- (cross);
    \draw [arrow] (cross) -- (mutate);
    \draw [arrow] (mutate) -- (replace);
    \draw [arrow] (replace) |- ([yshift=0.5cm]eval.east);
    \draw [arrow] (term) -| node [near start] {Yes} (output);
    
\end{tikzpicture}
\caption{Genetic Algorithm Cycle}
\end{figure}

\subsection{Phase 1: Initialization}
\begin{itemize}
    \item Create initial population of size $N$
    \item Generate individuals randomly or using heuristics
    \item Ensure population diversity
    \item Set generation counter $t = 0$
\end{itemize}

\subsection{Phase 2: Evaluation}
\begin{itemize}
    \item Calculate fitness for each individual
    \item Identify best and worst individuals
    \item Compute population statistics (average, variance)
\end{itemize}

\subsection{Phase 3: Termination Check}
Common termination criteria:
\begin{itemize}
    \item Maximum number of generations reached
    \item Fitness threshold achieved
    \item Population convergence (low diversity)
    \item No improvement for specified generations
    \item Maximum function evaluations reached
\end{itemize}

\subsection{Phase 4: Selection}
\begin{itemize}
    \item Choose parents for reproduction
    \item Bias selection toward fitter individuals
    \item Maintain population diversity
\end{itemize}

\subsection{Phase 5: Crossover}
\begin{itemize}
    \item Combine genetic material from selected parents
    \item Create offspring with traits from both parents
    \item Apply with probability $p_c$ (typically 0.6-0.9)
\end{itemize}

\subsection{Phase 6: Mutation}
\begin{itemize}
    \item Introduce random changes to offspring
    \item Maintain genetic diversity
    \item Apply with probability $p_m$ (typically 0.001-0.1)
\end{itemize}

\subsection{Phase 7: Replacement}
\begin{itemize}
    \item Form new population from parents and offspring
    \item Increment generation counter $t = t + 1$
    \item Return to evaluation phase
\end{itemize}

\section{Holland Schema Theory}

Schema theory, developed by John Holland, provides a theoretical foundation for understanding why genetic algorithms work effectively.

\subsection{What is a Schema?}
A schema is a template describing a subset of strings with similarities at certain positions. It uses three symbols:
\begin{itemize}
    \item \textbf{0}: Fixed bit value 0
    \item \textbf{1}: Fixed bit value 1
    \item \textbf{*}: Don't care symbol (wild card)
\end{itemize}

\textbf{Example}: Schema $H = 1*0*1$ represents all 5-bit strings with:
\begin{itemize}
    \item First bit = 1
    \item Third bit = 0
    \item Fifth bit = 1
    \item Second and fourth bits can be anything
\end{itemize}

Strings matching this schema: 10001, 10011, 11001, 11011

\subsection{Schema Properties}

\subsubsection{Order of a Schema}
The order $o(H)$ is the number of fixed positions (non-* symbols):
\begin{equation}
o(H) = \text{number of defined bits in } H
\end{equation}

For $H = 1*0*1$: $o(H) = 3$

\subsubsection{Defining Length}
The defining length $\delta(H)$ is the distance between the first and last fixed positions:
\begin{equation}
\delta(H) = \text{last fixed position} - \text{first fixed position}
\end{equation}

For $H = 1*0*1$: $\delta(H) = 5 - 1 = 4$

\subsection{Schema Theorem (Fundamental Theorem)}

The schema theorem describes how the expected number of strings matching a schema changes from generation to generation.

\subsubsection{Selection Effect}
If $m(H,t)$ is the number of strings matching schema $H$ at generation $t$, and $f(H)$ is the average fitness of strings matching $H$, then:

\begin{equation}
E[m(H,t+1)] \geq m(H,t) \cdot \frac{f(H)}{\bar{f}}
\end{equation}

where $\bar{f}$ is the average fitness of the population.

This means schemas with above-average fitness will increase in representation.

\subsubsection{Crossover Effect}
Crossover can disrupt a schema if the crossover point falls between the defining positions. The probability of schema survival is:

\begin{equation}
P_s = 1 - p_c \cdot \frac{\delta(H)}{l-1}
\end{equation}

where:
\begin{itemize}
    \item $p_c$ is the crossover probability
    \item $l$ is the string length
\end{itemize}

\subsubsection{Mutation Effect}
The probability that a schema survives mutation is:

\begin{equation}
P_m = (1 - p_m)^{o(H)}
\end{equation}

where $p_m$ is the mutation probability per bit.

\subsubsection{Combined Schema Theorem}
Combining all effects:

\begin{equation}
E[m(H,t+1)] \geq m(H,t) \cdot \frac{f(H)}{\bar{f}} \cdot \left(1 - p_c \cdot \frac{\delta(H)}{l-1}\right) \cdot (1 - p_m)^{o(H)}
\end{equation}

\subsection{Building Block Hypothesis}

The building block hypothesis states that:
\begin{itemize}
    \item Short, low-order, above-average schemas (building blocks) increase exponentially
    \item GA combines these building blocks to form optimal solutions
    \item Good solutions contain good building blocks
\end{itemize}

\subsubsection{Characteristics of Good Building Blocks}
\begin{enumerate}
    \item \textbf{Short defining length}: $\delta(H)$ is small
    \item \textbf{Low order}: $o(H)$ is small
    \item \textbf{Above-average fitness}: $f(H) > \bar{f}$
\end{enumerate}

\section{Implicit Parallelism}

GAs process many schemas simultaneously. For a population of size $n$ with string length $l$:
\begin{itemize}
    \item Number of possible schemas: $3^l$
    \item Useful schemas processed: $O(n^3)$
\end{itemize}

This massive implicit parallelism is a key strength of GAs.

\section{Deception and Schema Theory}

\subsection{Deceptive Problems}
Problems where low-order building blocks mislead the search away from the global optimum. 

\textbf{Example}: Trap function where building blocks point toward local optima.

\subsection{Overcoming Deception}
\begin{itemize}
    \item Increase population size
    \item Use diversity-preserving techniques
    \item Apply linkage learning
    \item Use multi-objective approaches
\end{itemize}

\section{Practical Implications}

\subsection{Encoding Design}
\begin{itemize}
    \item Minimize epistasis (gene interactions)
    \item Keep related variables close together
    \item Use appropriate representation for building blocks
\end{itemize}

\subsection{Parameter Settings}
\begin{itemize}
    \item Low mutation rate to preserve building blocks
    \item Moderate crossover rate for effective recombination
    \item Sufficient population size for schema sampling
\end{itemize}

\section{Limitations of Schema Theory}

\begin{itemize}
    \item Assumes infinite population size
    \item Ignores finite population effects
    \item Doesn't account for epistasis
    \item Limited to binary representations
    \item Overlooks linkage effects
\end{itemize}

\section{Modern Extensions}

\subsection{Walsh Analysis}
Mathematical framework extending schema theory using Walsh functions.

\subsection{Fitness Landscapes}
Analysis of problem difficulty using landscape topology.

\subsection{No Free Lunch Theorem}
States that no algorithm is superior across all possible problems.

\section{Chapter Summary}

This chapter covered the genetic algorithm cycle and Holland's schema theory. The GA cycle provides a systematic approach to evolutionary search, while schema theory explains why GAs work by processing building blocks in parallel. Understanding these concepts is essential for effective GA design and application.

\section{Key Concepts}
\begin{itemize}
    \item GA cycle phases and their purposes
    \item Schema representation and properties
    \item Schema theorem and its implications
    \item Building block hypothesis
    \item Implicit parallelism in GAs
    \item Deception and its challenges
\end{itemize}