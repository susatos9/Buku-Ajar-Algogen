\chapter{Siklus GA dan Teori Skema Holland}

\section{Siklus Algoritma Genetika}
Algoritma genetika mengikuti proses siklik yang meniru evolusi alami. Memahami siklus ini penting untuk mengimplementasikan dan menganalisis kinerja GA.

\subsection{Siklus GA secara Rinci}

Algoritma genetika dirancang untuk secara iteratif meningkatkan sekumpulan kandidat solusi. Proses dimulai dengan populasi solusi potensial dan secara berulang menerapkan operasi evaluasi dan variasi untuk bergerak menuju solusi yang lebih baik. Siklus umum ini bersifat modular: inisialisasi menyiapkan pencarian, evaluasi mengukur kualitas saat ini, dan seleksi membentuk generasi berikutnya. Langkah-langkah ini membentuk sebuah loop yang berlanjut hingga terpenuhi kondisi berhenti.

Alur operasi digambarkan pada diagram di bawah ini yang menunjukkan urutan aksi tipikal dalam GA klasik: inisialisasi, evaluasi, pengecekan terminasi, pemilihan orang tua, penerapan crossover dan mutasi, seleksi, dan kembali ke evaluasi. Setiap langkah memiliki banyak implementasi dan parameter yang memengaruhi eksplorasi dan eksploitasi; misalnya ukuran populasi, tekanan seleksi, tipe crossover, dan laju mutasi memengaruhi bagaimana pencarian menavigasi ruang solusi. Meskipun diagram memperlihatkan urutan sederhana, algoritma praktis sering menyertakan peningkatan seperti laju adaptif, atau pembaruan steady-state yang mengubah detail bagaimana keturunan dan induk digabungkan.

% Diagram siklus dihapus (mengandung label operator yang dihilangkan).

Inisialisasi adalah langkah praktis pertama dan menentukan titik awal pencarian. Populasi awal berukuran $N$ dapat dihasilkan secara acak untuk memberikan cakupan luas ruang solusi, atau diisi dengan heuristik spesifik masalah untuk memberi awal yang lebih baik di wilayah yang menjanjikan. Menjaga keberagaman pada populasi awal penting karena mengurangi risiko konvergensi prematur dan meningkatkan kemungkinan bahwa blok bangunan berguna hadir sejak awal. Selain kandidat solusi itu sendiri, inisialisasi biasanya mencakup penetapan penghitung atau parameter tingkat-algoritma, seperti indeks generasi $t = 0$, dan pencatatan status yang diperlukan untuk operator adaptif.

Evaluasi mengkuantifikasi seberapa baik setiap individu menyelesaikan masalah dan mengubah solusi mentah menjadi nilai fitness yang digunakan oleh GA. Langkah ini umumnya menghitung fungsi objektif atau fitness untuk setiap anggota populasi, dan dapat juga mengumpulkan statistik ringkasan seperti rata-rata populasi, varians, serta fitness terbaik dan terburuk. Statistik tersebut berguna untuk memantau kemajuan, mendiagnosis stagnasi, dan menggerakkan mekanisme adaptif. Karena evaluasi sering menjadi bagian paling mahal dari GA—terutama jika setiap komputasi fitness melibatkan simulasi atau perhitungan kompleks—praktisi memperhatikan efisiensi evaluasi dan penggunaan kembali komputasi bila memungkinkan.

Terminasi adalah keputusan kendali yang diperiksa setelah evaluasi untuk memutuskan apakah algoritma harus berhenti atau dilanjutkan. Kondisi berhenti umum termasuk mencapai jumlah generasi maksimum yang ditetapkan, mencapai ambang fitness yang memadai, mengamati konvergensi populasi atau keberagaman yang sangat rendah, tidak ada perbaikan selama sejumlah generasi tertentu, atau habisnya anggaran evaluasi fungsi. Memilih kriteria terminasi merupakan trade-off antara biaya komputasi dan kualitas solusi: berhenti terlalu awal berisiko kehilangan solusi lebih baik, sementara berjalan terlalu lama membuang sumber daya dengan pengembalian yang menurun. Dalam praktiknya seringkali digabungkan beberapa kondisi (misalnya berhenti apabila target fitness tercapai atau batas generasi dilewati).

% Penjelasan rinci tentang operator variasi (seleksi/crossover/mutasi) dihapus dari bab ini.


\subsection{Apa itu Skema?}
Skema adalah template formal yang didefinisikan di atas alfabet $\{0,1,*\}$. Untuk panjang string tetap $l$, sebuah skema
\[ H \in \{0,1,*\}^l \]
menentukan nilai yang dibutuhkan pada beberapa lokus dan membiarkan lokus lain tidak ditentukan (simbol "don't care"). Misalkan $\Sigma = \{0,1\}$ dan $\Sigma^l$ himpunan semua string biner panjang-$l$. Kita mengatakan sebuah string konkret $s\in\Sigma^l$ memenuhi skema $H$ (tulis $s\in[H]$) jika setiap posisi yang terdefinisi pada $H$ cocok dengan $s$:
\begin{equation}
 s \in [H] \quad:\!\Leftrightarrow\quad \forall i\in\{1,\dots,l\},\; H_i \neq * \Rightarrow s_i = H_i.
\end{equation}

Himpunan $[H] = \{s\in\Sigma^l : s\text{ matches }H\}$ adalah kelas ekivalen genom konkret yang direpresentasikan oleh $H$. Jika $k(H)$ menyatakan jumlah simbol don't-care pada $H$ (jadi $k(H)=|\{i:\;H_i=*\}|$), maka kardinalitas kelas ini adalah
\begin{equation}
 |[H]| = 2^{k(H)}.
\end{equation}

Dua kuantitas lain yang sering dipakai adalah orde dan panjang pendefinisian. Orde $o(H)$ sama dengan jumlah posisi yang tetap (simbol bukan-*), jadi $o(H)=l-k(H)$. Jika $i_{\min}$ dan $i_{\max}$ adalah indeks posisi tetap pertama dan terakhir pada $H$, panjang pendefinisian didefinisikan sebagai
\begin{equation}
 \delta(H) = i_{\max} - i_{\min}.
\end{equation}

Contoh: untuk $H=1*0*1$ dengan $l=5$ kita memiliki posisi tetap di indeks $1,3,5$, $k(H)=2$, $o(H)=3$, dan
\[ |[H]|=2^{2}=4, \qquad \delta(H)=5-1=4,\]
dengan string yang cocok \{10001,10011,11001,11011\}.

\subsection{Properti Skema}

\subsubsection{Orde Skema}
Orde $o(H)$ adalah jumlah posisi tetap (simbol bukan-*):
\begin{equation}
 o(H) = \text{jumlah bit terdefinisi pada } H
\end{equation}

Untuk $H = 1*0*1$: $o(H) = 3$

\subsubsection{Panjang Pendefinisian}
Panjang pendefinisian $\delta(H)$ mengukur rentang antara posisi tetap pertama dan terakhir pada pola. Secara intuitif, ini menunjukkan seberapa tersebar bit-bit penting skema sepanjang kromosom dan oleh karena itu seberapa terekspos skema tersebut terhadap kejadian rekombinasi. Secara formal dihitung sebagai selisih indeks antara posisi tetap terakhir dan pertama:
\begin{equation}
 \delta(H) = \text{posisi tetap terakhir} - \text{posisi tetap pertama}
\end{equation}

Panjang pendefinisian kecil berarti bit tetap skema berkumpul rapat.
Signifikansi praktis panjang pendefinisian terkait erat dengan pandangan blok-bangunan dalam GA: blok gen pendek yang saling terhubung yang memberi fitness di atas rata-rata.

Untuk $H = 1*0*1$: $\delta(H) = 5 - 1 = 4$

\textbf{Contoh dari Buku Ajar:}
\begin{itemize}
    \item $S_1 = (* * * 0 0 1 * 1 1 0)$: $\delta(S_1) = 10 - 4 = 6$
    \item $S_2 = (* * * * 0 0 * * 0 *)$: $\delta(S_2) = 9 - 5 = 4$
    \item $S_3 = (1 1 1 0 1 * * 0 0 1)$: $\delta(S_3) = 10 - 1 = 9$
\end{itemize}

\subsection{Teorema Skema (Teorema Fundamental)}
Teorema skema menjelaskan bagaimana jumlah harapan string yang memenuhi sebuah skema berubah dari satu generasi ke generasi berikutnya.


\subsubsection{Teorema Skema Gabungan}
Menggabungkan semua pengaruh:
\begin{equation}
 E[m(H,t+1)] \geq m(H,t) \cdot \frac{f(H)}{\bar{f}} \cdot \left(1 - p_c \cdot \frac{\delta(H)}{l-1}\right) \cdot (1 - p_m)^{o(H)}
\end{equation}

\subsection{Hipotesis Blok-Bangunan}
Hipotesis blok-bangunan dapat dinyatakan secara tepat menggunakan formalismo skema Holland: sebuah blok-bangunan adalah skema $H$ dengan panjang pendefinisian kecil $\delta(H)$, orde rendah $o(H)$, dan fitness di atas rata-rata $f(H) > \bar f$. Teorema skema memberi kriteria kuantitatif agar skema tersebut tumbuh dalam ekspektasi dari generasi $t$ ke $t+1$:
\begin{equation}
 E[m(H,t+1)] \ge m(H,t) \cdot \frac{f(H)}{\bar f} \cdot \left(1 - p_c\frac{\delta(H)}{l-1}\right) \cdot (1-p_m)^{o(H)}.
\end{equation}

Dengan demikian, kondisi yang diperlukan (tetapi tidak cukup) agar $H$ tumbuh secara harapan adalah faktor multiplikatif di ruas kanan melebihi satu. Menyusun ulang memberi kondisi ambang informal
\begin{equation}
 \frac{f(H)}{\bar f} > \frac{1}{\left(1 - p_c\frac{\delta(H)}{l-1}\right) (1-p_m)^{o(H)}}.
\end{equation}

Ketidaksamaan ini memperjelas trade-off: fitness relatif lebih tinggi, panjang pendefinisian lebih kecil, dan orde lebih rendah meningkatkan peluang sebuah skema berkembang.

\section{Paralelisme Implisit}
GA bekerja pada populasi genom konkret, tetapi setiap genom konkret secara simultan menginstansiasi keluarga skema yang jumlahnya eksponensial. Secara konkret, untuk string biner panjang $l$ ada $3^l$ skema yang mungkin (setiap posisi bisa 0, 1, atau "don't care"). Satu string panjang-$l$ cocok dengan tepat $2^l$ skema berbeda karena setiap lokus bisa dibiarkan tetap atau diganti simbol don't-care. Akibatnya, populasi berukuran $n$ menyediakan contoh langsung paling banyak $n2^l$ skema (menghitung multiplikitas), dan—mengabaikan tumpang tindih antar individu—angka ini bisa eksponensial besar terhadap $l$. Fakta kombinatorial ini mendasari gagasan intuitif bahwa GA mengevaluasi banyak skema secara paralel.

Perhitungan yang lebih rinci mengelompokkan skema menurut orde mereka (jumlah lokus tetap). Jumlah skema orde $r$ adalah
\begin{equation}
 \binom{l}{r}2^{r},
\end{equation}
karena dipilih $r$ lokus yang tetap lalu diberi bit (0 atau 1) pada setiap lokus tetap. Jumlah skema yang orde-nya tidak melebihi $k$ adalah
\begin{equation}
 S_k = \sum_{r=0}^k \binom{l}{r}2^{r},
\end{equation}
yang, untuk $k$ kecil tetap, tumbuh secara polinomial terhadap $l$ (derajat $k$) bukan eksponensial. 

Ungkapan terkenal Holland "paralelisme implisit" merangkum heuristik bahwa populasi berukuran sedang dapat secara kolektif mengevaluasi dan memproses sejumlah besar skema pendek dan orde-rendah pada setiap generasi. Dalam eksposisinya, ia menawarkan aturan praktis bahwa populasi $n$ string dapat efektif memproses urutan skema sebesar $n^3$; pernyataan ini harus dibaca sebagai heuristik, bukan identitas kombinatorial ketat. Angka $O(n^3)$ muncul dari asumsi tentang orde-orde tipikal dan panjang pendefinisian skema yang memengaruhi fitness, bersama dengan estimasi plausibel tentang berapa banyak skema pendek berbeda yang disampling populasi dan bagaimana seleksi memperkuat instance di atas rata-rata. Pilihan berbeda untuk $n$, $l$, representasi, dan pengaturan operator mengubah faktor konstanta dan jangkauan praktis paralelisme ini.

Implikasi praktisnya dua arah. Pertama, dengan bekerja pada populasi alih-alih satu lintasan pencarian tunggal, GA dapat menjelajah dan menyebarkan banyak blok-bangunan kandidat secara bersamaan, memungkinkan rekombinasi konstruktif pola-pola pendek yang berguna. Kedua, cakupan implisit ini bersifat selektif: algoritma menyalurkan daya pemrosesan efektif ke skema yang cukup sering disampling (muncul cukup sering) dan cukup tangguh (memiliki panjang pendefinisian kecil dan orde rendah). Akibatnya, paralelisme implisit bukanlah solusi ajaib yang memeriksa setiap skema sama rata; melainkan mengarahkan upaya komputasi kepada subset terstruktur besar dari skema yang paling relevan berdasarkan enkoding dan operator yang dipilih.

\section{Deception dan Teori Skema}

\subsection{Masalah Menipu (Deceptive)}
Deception terjadi ketika seleksi, yang bekerja pada sinyal fitness jangka pendek, secara sistematis mendorong populasi menjauh dari genotip yang menuju optimum global. Secara informal, sebuah fungsi fitness bersifat menipu terhadap sekumpulan skema orde-rendah jika skema yang tampak "terbaik" secara lokal (mis. memiliki fitness di atas rata-rata di antara instance-nya) adalah skema yang rekombinasinya tidak merakit solusi global melainkan mempromosikan genotip yang sulit diperbaiki. Dengan kata lain, seleksi memberi penghargaan pada blok-bangunan yang mengarahkan pencarian ke optimum lokal daripada ke optimum global.

Fenomena ini dapat dinyatakan dengan istilah skema. Pertimbangkan dua kelas skema terpisah $H_1$ dan $H_2$ yang didefinisikan pada set lokus terpisah. Jika instance paling fit dari $H_1$ dan $H_2$ cenderung menghasilkan keturunan yang gabungan fitnesnya lebih rendah daripada kombinasi alternatif (atau jika penggabungan mereka tidak mungkin di bawah operator yang dipilih), maka seleksi yang bekerja pada $H_1$ dan $H_2$ dapat meningkatkan frekuensi keduanya meskipun keberadaan bersama mereka merugikan tercapainya optimum global. Ketidaksesuaian antara fitness skema jangka pendek dan nilai konstruktif jangka panjang inilah inti deception.

Contoh benchmark klasik yang menggambarkan deception adalah masalah trap-deceptive yang dikonkatenasi. Genom dibagi menjadi $m$ blok terpisah masing-masing berukuran $k$. Setiap blok memberikan kontribusi fitness blok-wise yang maksimum pada konfigurasi tertentu (optimum global blok) tetapi selain itu memberikan fitness lebih tinggi pada konfigurasi yang menarik secara lokal namun tidak mengarah ke optimum blok. Jika blok-blok sederhana dan independen, rekombinasi dapat merakit optimum blok; jika blok menipu, seleksi memperkuat konfigurasi lokal yang salah dan rekombinasi saja mungkin tidak mampu menyelamatkan solusi global.

\subsection{Mengapa Deception Penting bagi Teori Skema}
Teori skema memprediksi bahwa skema orde-rendah dan panjang-pendefinisian pendek dengan fitness di atas rata-rata akan meningkat dalam ekspektasi di bawah seleksi. Deception merusak penalaran ini dengan membuat skema-skema lokal yang tampak di atas rata-rata justru menjauhkan populasi dari genotip yang mengandung kombinasi blok-bangunan optimal global. Jadi, walaupun pernyataan aljabar teorema skema tetap benar dalam ekspektasi, interpretasi konstruktifnya (bahwa seleksi akan merakit blok-bangunan baik menjadi solusi lebih baik) dapat gagal ketika skema pendek yang disampling menyesatkan.

\subsection{Mendeteksi dan Mengukur Deception}
Secara praktis, deception dinilai dengan menganalisis bagaimana perbaikan lokal berkorelasi dengan kemajuan global. Diagnostik umum meliputi:
\begin{itemize}
    \item Korelasi jarak-fitness (Fitness-Distance Correlation, FDC): korelasi antara fitness dan jarak ke optimum global yang diketahui. Korelasi negatif kuat menunjukkan pencarian lebih mudah; korelasi lemah atau positif dapat menandakan deception.
    \item Analisis blok empiris: untuk masalah yang dapat didekomposisi (mis. trap yang dikonkatenasi), mempelajari lanskap fitness blok-wise (plot unitation) mengungkap apakah optimum lokal menarik pencarian dalam blok.
    \item Sensitivitas performa: mengukur probabilitas keberhasilan sebagai fungsi ukuran populasi dan pengaturan operator dapat menunjukkan apakah perubahan kecil menghilangkan atau menimbulkan perilaku menipu.
\end{itemize}

\subsection{Strategi Mengatasi Deception}
Karena deception muncul dari ketidakcocokan antara representasi, operator, dan struktur modular masalah, langkah-langkah penanggulangannya umumnya jatuh pada tiga kategorial: meningkatkan sampling, mempertahankan diversitas yang berguna, dan meningkatkan kemampuan algoritma menghormati atau mempelajari linkage.
\begin{itemize}
    \item \textbf{Tingkatkan sampling efektif:} Populasi lebih besar dan tekanan seleksi konservatif mengurangi kemungkinan skema menipu cepat fix.
    \item \textbf{Metode pelestarian diversitas:} Niching (fitness sharing, crowding), model pulau, dan restricted tournament selection mempertahankan alel atau subpopulasi bersaing sehingga kombinasi blok alternatif tidak hilang prematur.
    \item \textbf{Pembelajaran linkage dan metode estimasi:} Algoritma yang mempelajari ketergantungan—messy GAs, linkage-tree GAs, hierarchical BOA, dan pemodelan struktur dependensi—secara eksplisit mendeteksi dan melindungi gen yang saling berinteraksi alih-alih bergantung pada rekombinasi buta.
    \item \textbf{Hibridisasi dan pencarian lokal:} Menggabungkan GA dengan pencarian lokal spesifik masalah (algoritma memetik) atau heuristik konstruktif membantu memperbaiki atau menyelesaikan solusi parsial yang rekombinasi murni tidak dapat rakit.
\end{itemize}

\section{Implikasi Praktis}

% Subsection on encoding/representation removed per user request.

\subsection{Pemilihan Operator dan Parameter}
Pertimbangan berdasarkan skema menunjukkan trade-off tertentu saat memilih operator dan parameternya:
\begin{itemize}
    \item \textbf{Ukuran populasi ($n$):} Populasi lebih besar mengurangi noise sampling dan meningkatkan probabilitas keberadaan skema orde-rendah yang berguna dalam multiplicity yang cukup. Gunakan aturan ukuran populasi atau eksperimen untuk memastikan sampling andal.
\end{itemize}

\subsection{Pemantauan dan Diagnostik Praktis}
Untuk menerapkan desain yang diinformasikan skema dalam praktik, pantau statistik populasi secara berkala:
\begin{itemize}
    \item Lacak keberagaman genotip (mis. frekuensi alel per-lokus) dan varians fenotip untuk mendeteksi konvergensi prematur.
    \item Hitung hitungan skema sederhana atau sampling skema kandidat untuk memverifikasi apakah blok-bangunan yang diharapkan ditemukan dan dipertahankan.
    \item Ukur metrik kemajuan (fitness terbaik, median, rata-rata) bersamaan dengan indikator keberagaman; perbaikan lambat dengan diversitas yang runtuh sering menandakan kegagalan rekombinasi skema.
\end{itemize}

\section{Keterbatasan Teori Skema}

Teori skema memberikan kerangka konseptual dan analitik yang bernilai, tetapi asumsi dan cakupannya menimbulkan keterbatasan penting yang harus dikenali praktisi.

\subsection{Ekspektasi vs dinamika populasi terbatas}
Pernyataan aljabar inti dari teori skema adalah pernyataan tentang ekspektasi. Pada populasi terbatas, noise sampling stokastik, genetic drift, dan galat sampling dapat menyebabkan dinamika realisasi menyimpang jauh dari ekspektasi. Oleh karena itu prediksi berbasis skema harus ditafsirkan sebagai kecenderungan, bukan hasil deterministik.

\subsection{Penanganan epistasis dan interaksi kompleks terbatas}
Teori skema paling informatif untuk pola orde-rendah dan panjang-pendefinisian pendek. Ketika fitness muncul dari interaksi orde-tinggi (epistasis kuat) atau dari dependensi terdistribusi yang kompleks antar lokus, hitungan skema mengaburkan struktur relevan dan menawarkan daya prediksi yang terbatas.

\subsection{Pembatasan pada alfabet sederhana dan enkoding panjang tetap}
Analisis skema klasik mengasumsikan alfabet biner dan string panjang tetap. Perlu reformulasi hati-hati untuk alfabet yang lebih kaya, genom ber- panjang variabel, atau enkoding tidak langsung; penerapan intuisi berbasis biner secara naif dapat menyesatkan.

\subsection{Kurangnya spesifikasi preskriptif}
Walaupun teori skema menjelaskan mengapa blok-bangunan pendek yang fit berguna, ia tidak memberikan algoritma preskriptif umum untuk menemukan representasi atau operator terbaik untuk masalah sewenang-wenang. Metode modern—pembelajaran linkage, EDAs, dan pendekatan pemodelan probabilistik—secara eksplisit mencoba mempelajari dan memanfaatkan struktur masalah yang tidak dapat diungkap hanya oleh hitungan skema.

\subsection{Protokol empiris yang direkomendasikan}
Saat menggunakan penalaran berbasis skema untuk membimbing desain algoritma, ikuti protokol empiris yang mengurangi risiko kesimpulan yang keliru:
\begin{itemize}
    \item Jalankan beberapa percobaan independen dan laporkan varians, bukan hanya rata-rata performa.
    \item Gunakan studi ablation terkontrol untuk mengukur efek pilihan representasi dan operator terhadap sampling dan pelestarian skema kandidat.
    \item Jika memungkinkan, visualisasikan lintasan frekuensi alel dan plot unitation per-blok untuk mendiagnosis kapan dan di mana skema berguna hilang atau dipertahankan.
    \item Bandingkan dengan baseline pemodelan (EDAs sederhana, GA peka-linkage) untuk menilai apakah rekombinasi buta cukup untuk masalah target.
\end{itemize}

\section{Teorema No Free Lunch}
Menyatakan bahwa tidak ada algoritma yang unggul di seluruh kemungkinan masalah.


