\chapter{Crossover (Recombination) in Genetic Algorithms}

\section{Introduction to Crossover}
Crossover, or recombination, is the primary genetic operator in genetic algorithms: it constructs new candidate solutions by combining genetic material from two (or more) parents. By recombining existing solutions, crossover leverages useful partial solutions—so-called building blocks—to produce offspring that may inherit and amplify beneficial traits while exploring nearby regions of the search space. In practice, crossover works together with selection and mutation to drive population-level search toward better solutions.

Biologically, crossover is inspired by sexual reproduction where chromosomes exchange segments during meiosis and genes assort independently into gametes. These natural mechanisms generate variation: offspring differ from their parents, which increases diversity and the raw material upon which selection can act. The analogy emphasizes two useful ideas for algorithms: mixing parental material to preserve and combine advantageous substructures, and introducing variation to avoid premature convergence.

Key phenomena from biology map directly to algorithm design. Crossing over swaps contiguous genetic segments (preserving local structure), independent assortment randomizes combinations of chromosomes (promoting novel mixes), and the resulting genetic diversity helps populations escape local optima. The notion of building blocks suggests that compact, high-quality gene combinations should be protected and recombined rather than destroyed by overly disruptive operators.

Crossover typically proceeds in three conceptual steps: select parents for mating (usually biased by fitness), choose one or more crossover points or a recombination scheme, and exchange genetic material to form offspring. Implementation details (where the cut points are placed or whether genes are blended arithmetically) determine how much structure is preserved versus how much novelty is introduced; these choices critically shape the search dynamics.

A practical control over crossover is its application probability $p_c$: the fraction of selected parent pairs that actually undergo recombination. Common practice places $p_c$ in the range $0.6$–$0.9$. High $p_c$ increases exploration by producing many new combinations each generation and can speed convergence when useful building blocks exist, while low $p_c$ places more emphasis on exploiting existing individuals and relies more on mutation and selection to introduce variation.

Crossover mediates the trade-off between exploration and exploitation. Exploitation arises when the operator successfully combines and preserves good substructures from parents, accelerating progress toward high-quality solutions. Exploration occurs when recombination produces novel configurations not present in either parent, increasing the chance of discovering better regions of the search space. Effective algorithm design tunes the operator so that both behaviors occur in balance.

The risk of schema disruption—breaking apart useful gene combinations—depends on how crossover is implemented and where cuts occur. Less disruptive schemes preserve adjacent relationships and short schemas, while more disruptive schemes (or many cut points) can destroy long, coadapted gene patterns even as they increase diversity. Awareness of these effects guides the choice of crossover style and its parameters for a given problem domain.

In practice, designers choose crossover type and rate based on representation, problem structure, and empirical testing: start with standard $p_c$ values (around $0.8$), monitor diversity and progress, and adjust to favor either preservation of building blocks or increased exploration as needed. Because crossover interacts with selection, population size, and mutation, tuning should be done holistically and validated by experiments on representative problem instances.

\section{Binary Crossover Operators}

\subsection{Definition and Function of Crossover Operator}
Crossover is a genetic operator used to vary the arrangement of chromosomes from one generation to the next~\cite{geeksforgeeks_crossover, tutorialspoint_crossover, course_week4_crossover}. The crossover method used depends on the encoding method applied.

In practice, crossover occurs in three stages: the reproduction operator selects a pair of individuals for mating, a crossover site is chosen along the length of the string, and the values after that site are exchanged between the two parents to form new offspring.

In binary chromosome representation, each individual in the population is represented as a sequence of bits (0 and 1) that express a potential solution to a problem.

\subsection{One-Point Crossover}
Single point crossover is the simplest form of crossover. One crossover position is randomly selected, then the part of the two parents after that position is exchanged to form two new offspring. The strings resulting from this process have Positional Bias characteristics.

\begin{figure}[h]
\centering
\includegraphics[width=0.7\textwidth]{figures/buku_ajar_page_24.png}
\caption{Single Point Crossover for binary chromosomes}
\label{fig:binary_single_point}
\end{figure}

\subsection{One-Point Crossover}
Single crossover point divides chromosomes into two segments.

\subsubsection{Algorithm}
\begin{algorithm}[H]
\caption{One-Point Crossover}
\begin{algorithmic}
\STATE $k \leftarrow$ RandomInteger(1, $l-1$)
\STATE $child1 \leftarrow parent1[1{:}k] \mathbin{+} parent2[k+1{:}l]$
\STATE $child2 \leftarrow parent2[1{:}k] \mathbin{+} parent1[k+1{:}l]$
\end{algorithmic}
\end{algorithm}

\subsubsection{Example}
\begin{align}
\text{Parent 1:} &\quad 1|1010011 \\
\text{Parent 2:} &\quad 0|0111100 \\
\text{Child 1:} &\quad 1|0111100 \\
\text{Child 2:} &\quad 0|1010011
\end{align}

Crossover point at position 1.

\subsubsection{Characteristics}
Single-point crossover is simple and efficient; it tends to preserve long building blocks near chromosome ends but may disrupt blocks that cross the crossover point, producing a positional bias where end positions are less likely to be separated.

\subsection{Two-Point Crossover}
Two crossover points create three segments.

Multi-point crossover has a mechanism like single-point crossover; the difference is the number of randomly selected positions. In Multi-point crossover, a number N of positions are randomly selected along the length of the chromosome. These positions are exchanged to form two new offspring.

The objectives of multi-point crossover include increasing genetic diversity in the population, reducing positional bias, and increasing the chances of recombination from various schemas or different solution blocks. However, using too many cut points can become too disruptive, as it can damage already good gene combinations (coadapted alleles).

\begin{figure}[h]
\centering
\includegraphics[width=0.7\textwidth]{figures/buku_ajar_page_25.png}
\caption{Multi-point Crossover for binary chromosomes}
\label{fig:binary_multi_point}
\end{figure}

\subsubsection{Algorithm}
\begin{algorithm}[H]
\caption{Two-Point Crossover}
\begin{algorithmic}
\STATE $(k_1,k_2) \leftarrow$ Two distinct random integers with $1 \le k_1 < k_2 \le l-1$
\STATE $child1 \leftarrow parent1[1{:}k_1] \mathbin{+} parent2[k_1+1{:}k_2] \mathbin{+} parent1[k_2+1{:}l]$
\STATE $child2 \leftarrow parent2[1{:}k_1] \mathbin{+} parent1[k_1+1{:}k_2] \mathbin{+} parent2[k_2+1{:}l]$
\end{algorithmic}
\end{algorithm}

\subsubsection{Example}
\begin{align}
\text{Parent 1:} &\quad 11|010|011 \\
\text{Parent 2:} &\quad 00|111|100 \\
\text{Child 1:} &\quad 11|111|011 \\
\text{Child 2:} &\quad 00|010|100
\end{align}

Crossover points at positions 2 and 5.

\subsubsection{Advantages}
Two-point crossover reduces positional bias and can preserve building blocks at chromosome ends, although it is generally more disruptive than one-point crossover.

\subsection{Uniform Crossover}
Each gene is independently chosen from either parent~\cite{spears1993crossover, eshelman1991chc}.

In uniform crossover, each gene (bit) is randomly selected from one of the corresponding genes on the parent chromosome. This selection process is done independently for each gene position. This method can be analogized to tossing a coin. If the result is "head", the gene is taken from parent 1; if the result is "tail", the gene is taken from parent 2.

This method provides equal opportunity for each gene to be inherited from one of the parents, thereby increasing genetic diversity and eliminating positional bias that typically appears in single-point crossover or multi-point crossover.

\begin{figure}[h]
\centering
\includegraphics[width=0.7\textwidth]{figures/buku_ajar_page_25.png}
\caption{Uniform Crossover for binary chromosomes}
\label{fig:binary_uniform}
\end{figure}

\subsubsection{Algorithm}
\begin{algorithm}[H]
\caption{Uniform Crossover}
\begin{algorithmic}
\FOR{$i = 1$ to $l$}
    \STATE $r \leftarrow$ UniformRandom(0,1)
    \IF{$r < 0.5$}
        \STATE $child1[i] \leftarrow parent1[i]$; $child2[i] \leftarrow parent2[i]$
    \ELSE
        \STATE $child1[i] \leftarrow parent2[i]$; $child2[i] \leftarrow parent1[i]$
    \ENDIF
\ENDFOR
\end{algorithmic}
\end{algorithm}

\subsubsection{Example with Mask}
\begin{align}
\text{Parent 1:} &\quad 11010011 \\
\text{Parent 2:} &\quad 00111100 \\
\text{Mask:} &\quad 10110100 \\
\text{Child 1:} &\quad 10111011 \\
\text{Child 2:} &\quad 01010100
\end{align}

Mask bit 1: take from Parent 1, Mask bit 0: take from Parent 2.

\subsubsection{Properties}
Uniform crossover has a high disruption potential and eliminates positional bias; it is useful when gene positions are independent but can destroy long building blocks.

\subsection{Multi-Point Crossover}
Generalization with $k$ crossover points.

\subsubsection{Characteristics}
Multi-point crossover generalizes from no crossover ($k=0$, copy parents) through one-point ($k=1$) up to the limit $k=l-1$ which approaches uniform crossover in expectation; increasing $k$ moves the operator closer to uniform recombination.

\section{Integer Chromosome Crossover}

Unlike binary chromosomes that use bits 0 and 1, integer representation is more suitable for problems involving discrete parameters or numerical values that have quantitative meaning, such as scheduling, sequencing, or combinatorial optimization.

\subsection{Single-Point Crossover for Integer}
Single-Point Crossover is the simplest form of crossover. One crossover position is randomly selected, then the part of the two parents after that position is exchanged to form two new offspring. The strings resulting from this process have Positional Bias characteristics.

\begin{figure}[h]
\centering
\includegraphics[width=0.7\textwidth]{figures/buku_ajar_page_28.png}
\caption{Single-Point Crossover for integer chromosomes}
\label{fig:integer_single_point}
\end{figure}

\subsection{Multi-point Crossover for Integer}
Multi-point crossover has a mechanism like single-point crossover; the difference is the number of randomly selected positions. In Multi-point crossover, a number N of positions are randomly selected along the length of the chromosome. These positions are exchanged to form two new offspring.

The objectives of multi-point crossover include increasing genetic diversity in the population, reducing positional bias, and increasing the chances of recombination from various schemas or different solution blocks. However, using too many cut points can become too disruptive, as it can damage already good gene combinations (coadapted alleles).

\begin{figure}[h]
\centering
\includegraphics[width=0.7\textwidth]{figures/buku_ajar_page_28.png}
\caption{Multi-point Crossover for integer chromosomes}
\label{fig:integer_multi_point}
\end{figure}

\subsection{Uniform Crossover for Integer}
In uniform crossover, each gene is randomly selected from one of the corresponding genes on the parent chromosome. This selection process is done independently for each gene position. This method can be analogized to tossing a coin. If the result is "head", the gene is taken from parent 1; if the result is "tail", the gene is taken from parent 2.

This method provides equal opportunity for each gene to be inherited from one of the parents, thereby increasing genetic diversity and eliminating positional bias that typically appears in single-point crossover or multi-point crossover.

\begin{figure}[h]
\centering
\includegraphics[width=0.7\textwidth]{figures/buku_ajar_page_29.png}
\caption{Uniform Crossover for integer chromosomes}
\label{fig:integer_uniform}
\end{figure}

\section{Real-Valued Crossover Operators}

Crossover on real chromosomes is a genetic recombination process in Genetic Algorithms applied to chromosomes represented in real number form (floating-point representation). This representation is commonly used to solve continuous optimization problems, where decision variables have values within a certain range and are not limited to integers or binary.

Unlike crossover on binary or integer chromosomes, the crossover mechanism for real chromosomes involves arithmetic operations on gene values between parents. This method allows the creation of offspring with gene values that are between or around the parent gene values, thus maintaining the continuity and stability of the evolution process.

\subsection{Arithmetic Crossover}
Linear combination of parent vectors.

\subsubsection{Single Arithmetic Crossover}
\begin{enumerate}
    \item Two parents are represented as:
    \begin{itemize}
        \item Parent 1: $\langle x_1, \ldots, x_n \rangle$
        \item Parent 2: $\langle y_1, \ldots, y_n \rangle$
    \end{itemize}
    \item Randomly select one gene ($k$) to undergo crossover operation
    \item The result is two offspring formed based on a linear combination of the $k$-th gene of those parents with control parameter $\alpha$, where $0 \leq \alpha \leq 1$:
    \begin{itemize}
        \item Offspring 1: $\langle x_1, \ldots, x_{k-1}, \alpha \cdot y_k + (1-\alpha) \cdot x_k, x_{k+1}, \ldots, x_n \rangle$
        \item Offspring 2: $\langle y_1, \ldots, y_{k-1}, \alpha \cdot x_k + (1-\alpha) \cdot y_k, y_{k+1}, \ldots, y_n \rangle$
    \end{itemize}
\end{enumerate}

\begin{figure}[h]
\centering
\includegraphics[width=0.7\textwidth]{figures/buku_ajar_page_31.png}
\caption{Single Arithmetic Crossover for real chromosomes}
\label{fig:real_single_arithmetic}
\end{figure}

\subsubsection{Simple Arithmetic Crossover}
\begin{enumerate}
    \item Two parents are represented as:
    \begin{itemize}
        \item Parent 1: $\langle x_1, \ldots, x_n \rangle$
        \item Parent 2: $\langle y_1, \ldots, y_n \rangle$
    \end{itemize}
    \item Randomly select one gene ($k$) to become the crossover boundary point
    \item The result is two offspring formed based on a linear combination from gene $k+1$ to gene $n$ with control parameter $\alpha$, where $0 \leq \alpha \leq 1$:
    \begin{itemize}
        \item Offspring 1: $\langle x_1, \ldots, x_k, \alpha \cdot y_{k+1} + (1-\alpha) \cdot x_{k+1}, \ldots, \alpha \cdot y_n + (1-\alpha) \cdot x_n \rangle$
        \item Offspring 2: $\langle y_1, \ldots, y_k, \alpha \cdot x_{k+1} + (1-\alpha) \cdot y_{k+1}, \ldots, \alpha \cdot x_n + (1-\alpha) \cdot y_n \rangle$
    \end{itemize}
\end{enumerate}

\begin{figure}[h]
\centering
\includegraphics[width=0.7\textwidth]{figures/buku_ajar_page_32.png}
\caption{Simple Arithmetic Crossover for real chromosomes}
\label{fig:real_simple_arithmetic}
\end{figure}

\subsubsection{Whole Arithmetic Crossover}
\begin{enumerate}
    \item Two parents are represented as:
    \begin{itemize}
        \item Parent 1: $\langle x_1, \ldots, x_n \rangle$
        \item Parent 2: $\langle y_1, \ldots, y_n \rangle$
    \end{itemize}
    \item For each gene $i$ ($i = 1, 2, \ldots, n$), offspring are formed with a linear combination of genes from both parents with control parameter $\alpha$, where $0 \leq \alpha \leq 1$:
    \begin{itemize}
        \item Offspring 1: $z_i^1 = \alpha \cdot y_i + (1-\alpha) \cdot x_i$
        \item Offspring 2: $z_i^2 = \alpha \cdot x_i + (1-\alpha) \cdot y_i$
    \end{itemize}
\end{enumerate}

\begin{figure}[h]
\centering
\includegraphics[width=0.7\textwidth]{figures/buku_ajar_page_32.png}
\caption{Whole Arithmetic Crossover for real chromosomes}
\label{fig:real_whole_arithmetic}
\end{figure}

\subsubsection{Whole Arithmetic Crossover}
\begin{align}
\mathbf{child_1} &= \alpha \mathbf{parent_1} + (1-\alpha) \mathbf{parent_2} \\
\mathbf{child_2} &= (1-\alpha) \mathbf{parent_1} + \alpha \mathbf{parent_2}
\end{align}

where $\alpha \in [0,1]$ is a random weight.

\subsubsection{Simple Arithmetic Crossover}
Apply arithmetic crossover to a random subset of genes.

\subsubsection{Single Arithmetic Crossover}
Apply arithmetic crossover to one randomly selected gene.

\subsubsection{Example}
\begin{align}
\text{Parent 1:} &\quad (2.1, 5.7, 1.3, 8.9) \\
\text{Parent 2:} &\quad (4.2, 3.1, 6.8, 2.4) \\
\text{Child 1 ($\alpha=0.3$):} &\quad (3.57, 4.49, 4.98, 4.17) \\
\text{Child 2 ($\alpha=0.3$):} &\quad (2.73, 4.32, 2.98, 6.17)
\end{align}

\subsection{BLX-$\alpha$ Crossover (Blend Crossover)}
Creates offspring in an interval around the parents.

\subsubsection{Algorithm}
\begin{algorithm}[H]
\caption{BLX-$\alpha$ Crossover}
\begin{algorithmic}
\FOR{$i = 1$ to $n$}
    \STATE $c_{min} \leftarrow \min(parent1[i], parent2[i])$
    \STATE $c_{max} \leftarrow \max(parent1[i], parent2[i])$
    \STATE $I \leftarrow c_{max} - c_{min}$
    \STATE Sample $child[i]$ uniformly from $[c_{min} - \alpha I,\; c_{max} + \alpha I]$
\ENDFOR
\end{algorithmic}
\end{algorithm}

\subsubsection{Parameters}
\begin{itemize}
    \item $\alpha = 0$: Offspring between parents
    \item $\alpha = 0.5$: Standard BLX-0.5
    \item Larger $\alpha$: More exploration beyond parents
\end{itemize}

\subsection{SBX (Simulated Binary Crossover)}
Simulates the behavior of one-point crossover for real-valued genes.

\subsubsection{Formula}
\begin{align}
child_{1i} &= 0.5[(1+\beta_i)parent_{1i} + (1-\beta_i)parent_{2i}] \\
child_{2i} &= 0.5[(1-\beta_i)parent_{1i} + (1+\beta_i)parent_{2i}]
\end{align}

where $\beta_i$ is calculated from:
\begin{equation}
\beta_i = \begin{cases}
(2u_i)^{1/(\eta_c+1)} & \text{if } u_i \leq 0.5 \\
\left(\frac{1}{2(1-u_i)}\right)^{1/(\eta_c+1)} & \text{if } u_i > 0.5
\end{cases}
\end{equation}

$u_i \sim U[0,1]$ and $\eta_c$ is the distribution index.

\section{Permutation Crossover Operators}

\subsection{Order Crossover (OX)}
Preserves relative order of elements from one parent~\cite{oliver1987study, larranaga1999genetic}.

\subsubsection{Algorithm}
\begin{algorithm}[H]
\caption{Order Crossover (OX)}
\begin{algorithmic}
\STATE Choose two crossover points $a,b$ with $1 \le a < b \le n$
\STATE Copy segment $parent1[a{:}b]$ into $child[a{:}b]$
\STATE $pos \leftarrow b+1$ (wrap to 1 if $> n$)
\FOR{each element $x$ in $parent2$ in order}
    \IF{$x$ not in $child$}
        \STATE $child[pos] \leftarrow x$
        \STATE $pos \leftarrow pos+1$ (wrap to 1 if $> n$)
    \ENDIF
\ENDFOR
\end{algorithmic}
\end{algorithm}

\subsubsection{Example}
\begin{align}
\text{Parent 1:} &\quad (1, 2, 3, 4, 5, 6, 7, 8, 9) \\
\text{Parent 2:} &\quad (9, 3, 7, 8, 2, 6, 5, 1, 4) \\
\text{Copy segment:} &\quad (\_, \_, 3, 4, 5, 6, \_, \_, \_) \\
\text{Fill from P2:} &\quad (7, 8, 3, 4, 5, 6, 2, 1, 9)
\end{align}

\subsection{Partially Mapped Crossover (PMX)}
Creates mapping between elements in the crossover segment~\cite{goldberg1989genetic, larranaga1999genetic}.

\subsubsection{Algorithm}
\begin{algorithm}[H]
\caption{Partially Mapped Crossover (PMX)}
\begin{algorithmic}
\STATE Choose two crossover points $a,b$ with $1 \le a < b \le n$
\STATE Copy $parent1[a{:}b]$ into $child1[a{:}b]$ and $parent2[a{:}b]$ into $child2[a{:}b]$
\STATE Create mapping pairs from exchanged segments
\FOR{each position $i$ outside $[a,b]$}
    \STATE $val \leftarrow parent1[i]$
    \WHILE{$val$ is already in $child1[a{:}b]$}
        \STATE $val \leftarrow$ mapping of $val$ (follow mapping until an unused value found)
    \ENDWHILE
    \STATE $child1[i] \leftarrow val$
    \COMMENT{Repeat symmetrically for $child2$}
\ENDFOR
\end{algorithmic}
\end{algorithm}

\subsubsection{Example}
\begin{align}
\text{Parent 1:} &\quad (1, 2, 3, 4, 5, 6, 7, 8, 9) \\
\text{Parent 2:} &\quad (5, 4, 6, 9, 2, 3, 7, 1, 8) \\
\text{Mapping:} &\quad 3 \leftrightarrow 6, 4 \leftrightarrow 9, 5 \leftrightarrow 2, 6 \leftrightarrow 3 \\
\text{Child 1:} &\quad (1, 5, 6, 9, 2, 3, 7, 8, 4)
\end{align}

\subsection{Cycle Crossover (CX)}
Preserves absolute positions of elements from both parents~\cite{oliver1987study, reeves1993modern}.

\subsubsection{Algorithm}
\begin{algorithm}[H]
\caption{Cycle Crossover (CX)}
\begin{algorithmic}
\STATE Initialize all positions as unassigned
\STATE $cycleStart \leftarrow 1$
\WHILE{there are unassigned positions}
    \STATE $i \leftarrow cycleStart$
    \STATE Build cycle: add $i$ to cycle; set $i \leftarrow$ position of $parent1[i]$ in $parent2$; repeat until returning to $cycleStart$
    \STATE For indices in cycle assign values from $parent1$ to $child1$ and from $parent2$ to $child2$
    \STATE Choose next unassigned position as new $cycleStart$
\ENDWHILE
\end{algorithmic}
\end{algorithm}

\subsection{Edge Recombination Crossover}
Preserves edge information from both parents (useful for TSP).

\subsubsection{Algorithm}
\begin{algorithm}[H]
\caption{Edge Recombination Crossover}
\begin{algorithmic}
\STATE Build edge table: for each element list its neighbors from both parents (no duplicates)
\STATE $current \leftarrow$ element with fewest edges (break ties randomly)
\FOR{$pos = 1$ to $n$}
    \STATE $child[pos] \leftarrow current$
    \STATE Remove $current$ from all edge lists
    \IF{edge table of $current$ has any neighbors}
        \STATE $next \leftarrow$ neighbor of $current$ with fewest edges (break ties randomly)
    \ELSE
        \STATE $next \leftarrow$ random unused element
    \ENDIF
    \STATE $current \leftarrow next$
\ENDFOR
\end{algorithmic}
\end{algorithm}

\section{Crossover Analysis}

\subsection{Schema Disruption}
The probability that a schema $H$ is disrupted by crossover:

\subsubsection{One-Point Crossover}
\begin{equation}
P_{disruption} = p_c \cdot \frac{\delta(H)}{l-1}
\end{equation}

\subsubsection{Two-Point Crossover}
\begin{equation}
P_{disruption} = p_c \cdot \left(\frac{2\delta(H)}{l-1} - \frac{\delta(H)(\delta(H)-1)}{(l-1)(l-2)}\right)
\end{equation}

\subsubsection{Uniform Crossover}
\begin{equation}
P_{disruption} = p_c \cdot \left(1 - \left(\frac{1}{2}\right)^{o(H)-1}\right)
\end{equation}

\subsection{Building Block Preservation}
Short schemas are generally better preserved by crossover operators, while long schemas are more likely to be disrupted (particularly by uniform crossover); tightly linked genes benefit from permutation operators such as order crossover which preserve adjacency relationships.

\section{Advanced Crossover Techniques}

\subsection{Adaptive Crossover}
Adaptive crossover adjusts parameters dynamically based on signals such as population diversity, fitness improvement rate, generation number, and individual fitness levels.

\subsection{Multiple Parent Crossover}
Multiple-parent crossover combines material from more than two parents (see \cite{elsayed2011ga, yassen2012multi, fajrin2020multi, chen2013multiple}); examples include scanning crossovers that traverse parents sequentially, voting crossovers that use a majority rule, and averaging crossovers that compute averages of parent gene values.

\subsection{Problem-Specific Crossover}
Problem-specific crossover operators are designed to preserve domain constraints and useful structure: for graph problems preserve graph properties, for scheduling preserve temporal constraints, and for neural networks preserve network topology.

\section{Crossover Guidelines}

\subsection{Choosing Crossover Type}
Choose crossover type to match the representation: for binary use one-point, two-point, or uniform; for real-valued use arithmetic, BLX-$\alpha$, or SBX; for permutations use OX, PMX, or CX depending on problem structure; variable-length representations require specialized operators.

\subsection{Parameter Setting}
Typical parameter suggestions: start with crossover rate $p_c\approx0.8$--$0.9$; larger populations can tolerate higher crossover rates; harder problems may benefit from lower rates and more conservative recombination.

\subsection{Empirical Testing}
Empirical testing should compare multiple crossover operators, vary parameters, measure diversity and convergence, and include problem-specific metrics to validate choices.

