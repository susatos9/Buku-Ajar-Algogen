\chapter{Implementasi Algoritma}

\section{Implementasi Algoritma Genetika Dasar}

\subsection{Implementasi Python}

\begin{lstlisting}[language=Python, caption=Algoritma Genetika Dasar dalam Python]
import numpy as np
import matplotlib.pyplot as plt
from typing import List, Tuple, Callable

class GeneticAlgorithm:
    def __init__(self, 
                 fitness_func: Callable,
                 chromosome_length: int,
                 population_size: int = 100,
                 crossover_rate: float = 0.8,
                 mutation_rate: float = 0.01,
                 elitism: bool = True):
        
        self.fitness_func = fitness_func
        self.chromosome_length = chromosome_length
        self.population_size = population_size
        self.crossover_rate = crossover_rate
        self.mutation_rate = mutation_rate
        self.elitism = elitism
        
        # Initialize population
        self.population = self._initialize_population()
        self.fitness_history = []
        self.best_individual = None
        self.best_fitness = float('-inf')
    
    def _initialize_population(self) -> np.ndarray:
        """Inisialisasi populasi biner acak"""
        return np.random.randint(0, 2,
                               (self.population_size, self.chromosome_length))
    
    def _evaluate_fitness(self, population: np.ndarray) -> np.ndarray:
        """Evaluasi fungsi kesesuaian untuk semua individu"""
        fitness_values = np.array([self.fitness_func(individual)
                                  for individual in population])
        return fitness_values
    
    def _tournament_selection(self, population: np.ndarray,
                            fitness_values: np.ndarray,
                            tournament_size: int = 3) -> np.ndarray:
        """Seleksi turnamen"""
        selected = []
        for _ in range(len(population)):
            # Pilih individu acak untuk turnamen
            tournament_indices = np.random.choice(len(population),
                                                tournament_size,
                                                replace=False)
            tournament_fitness = fitness_values[tournament_indices]

            # Pilih pemenang
            winner_index = tournament_indices[np.argmax(tournament_fitness)]
            selected.append(population[winner_index])

        return np.array(selected)
    
    def _one_point_crossover(self, parent1: np.ndarray,
                           parent2: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:
        """Persilangan satu titik (one-point crossover)"""
        if np.random.random() > self.crossover_rate:
            return parent1.copy(), parent2.copy()

        crossover_point = np.random.randint(1, len(parent1))

        child1 = np.concatenate([parent1[:crossover_point],
                               parent2[crossover_point:]])
        child2 = np.concatenate([parent2[:crossover_point],
                               parent1[crossover_point:]])

        return child1, child2
    
    def _bit_flip_mutation(self, individual: np.ndarray) -> np.ndarray:
        """Mutasi bit-flip"""
        mutated = individual.copy()
        for i in range(len(mutated)):
            if np.random.random() < self.mutation_rate:
                mutated[i] = 1 - mutated[i]  # Membalik bit
        return mutated
    
    def _apply_elitism(self, old_population: np.ndarray,
                      old_fitness: np.ndarray,
                      new_population: np.ndarray) -> np.ndarray:
        """Terapkan elitisme dengan mempertahankan individu terbaik"""
        if not self.elitism:
            return new_population

        best_index = np.argmax(old_fitness)
        best_individual = old_population[best_index]

        # Gantikan individu terburuk di populasi baru dengan yang terbaik dari lama
        new_fitness = self._evaluate_fitness(new_population)
        worst_index = np.argmin(new_fitness)
        new_population[worst_index] = best_individual

        return new_population
    
    def evolve(self, generations: int) -> dict:
        """Loop evolusi utama"""
        for generation in range(generations):
            # Evaluasi kesesuaian
            fitness_values = self._evaluate_fitness(self.population)

            # Lacak individu terbaik
            max_fitness_idx = np.argmax(fitness_values)
            if fitness_values[max_fitness_idx] > self.best_fitness:
                self.best_fitness = fitness_values[max_fitness_idx]
                self.best_individual = self.population[max_fitness_idx].copy()

            # Catat statistik
            self.fitness_history.append({
                'generation': generation,
                'best_fitness': np.max(fitness_values),
                'avg_fitness': np.mean(fitness_values),
                'worst_fitness': np.min(fitness_values)
            })

            # Seleksi
            selected = self._tournament_selection(self.population, fitness_values)

            # Persilangan dan mutasi
            new_population = []
            for i in range(0, len(selected), 2):
                parent1 = selected[i]
                parent2 = selected[(i + 1) % len(selected)]

                # Persilangan
                child1, child2 = self._one_point_crossover(parent1, parent2)

                # Mutasi
                child1 = self._bit_flip_mutation(child1)
                child2 = self._bit_flip_mutation(child2)

                new_population.extend([child1, child2])

            new_population = np.array(new_population[:self.population_size])

            # Terapkan elitisme
            self.population = self._apply_elitism(self.population,
                                                fitness_values,
                                                new_population)

        return {
            'best_individual': self.best_individual,
            'best_fitness': self.best_fitness,
            'fitness_history': self.fitness_history
        }
    
    def plot_fitness_history(self):
        """Plot evolusi kesesuaian sepanjang generasi"""
        generations = [entry['generation'] for entry in self.fitness_history]
        best_fitness = [entry['best_fitness'] for entry in self.fitness_history]
        avg_fitness = [entry['avg_fitness'] for entry in self.fitness_history]

        plt.figure(figsize=(10, 6))
        plt.plot(generations, best_fitness, label='Kesesuaian Terbaik', linewidth=2)
        plt.plot(generations, avg_fitness, label='Kesesuaian Rata-rata', linewidth=2)
        plt.xlabel('Generasi')
        plt.ylabel('Kesesuaian')
        plt.title('Evolusi Kesesuaian')
        plt.legend()
        plt.grid(True, alpha=0.3)
        plt.show()

# Example usage
def onemax_fitness(individual):
    """Masalah OneMax: maksimalkan jumlah bit bernilai 1"""
    return np.sum(individual)

def sphere_function_binary(individual, bounds=(-5.12, 5.12)):
    """Fungsi Sphere dengan encoding biner"""
    # Dekode biner ke nilai riil
    x = bounds[0] + (bounds[1] - bounds[0]) * np.sum(individual * 2**np.arange(len(individual))[::-1]) / (2**len(individual) - 1)
    return -(x**2)  # Negatif karena kita ingin meminimalkan

# Run GA on OneMax problem
if __name__ == "__main__":
    ga = GeneticAlgorithm(
        fitness_func=onemax_fitness,
        chromosome_length=20,
        population_size=50,
        crossover_rate=0.8,
        mutation_rate=0.01
    )

    result = ga.evolve(generations=100)

    print(f"Individu terbaik: {result['best_individual']}")
    print(f"Kesesuaian terbaik: {result['best_fitness']}")

    ga.plot_fitness_history()
\end{lstlisting}

\section{Algoritma Genetika Bernilai Riil}

\begin{lstlisting}[language=Python, caption=Implementasi GA Bernilai Riil]
import numpy as np
from typing import List, Tuple, Callable

class RealValuedGA:
    def __init__(self, 
                 fitness_func: Callable,
                 dimensions: int,
                 bounds: List[Tuple[float, float]],
                 population_size: int = 100,
                 crossover_rate: float = 0.8,
                 mutation_rate: float = 0.1,
                 mutation_strength: float = 0.1):
        
        self.fitness_func = fitness_func
        self.dimensions = dimensions
        self.bounds = bounds
        self.population_size = population_size
        self.crossover_rate = crossover_rate
        self.mutation_rate = mutation_rate
        self.mutation_strength = mutation_strength
        
        self.population = self._initialize_population()
        self.fitness_history = []
    
    def _initialize_population(self) -> np.ndarray:
        """Inisialisasi populasi bernilai riil acak"""
        population = np.zeros((self.population_size, self.dimensions))
        for i in range(self.dimensions):
            low, high = self.bounds[i]
            population[:, i] = np.random.uniform(low, high, self.population_size)
        return population
    
    def _blx_alpha_crossover(self, parent1: np.ndarray,
                           parent2: np.ndarray,
                           alpha: float = 0.5) -> Tuple[np.ndarray, np.ndarray]:
        """Persilangan BLX-alpha"""
        if np.random.random() > self.crossover_rate:
            return parent1.copy(), parent2.copy()
        
        child1 = np.zeros_like(parent1)
        child2 = np.zeros_like(parent2)
        
        for i in range(len(parent1)):
            min_val = min(parent1[i], parent2[i])
            max_val = max(parent1[i], parent2[i])
            interval = max_val - min_val
            
            low_bound = max(min_val - alpha * interval, self.bounds[i][0])
            high_bound = min(max_val + alpha * interval, self.bounds[i][1])
            
            child1[i] = np.random.uniform(low_bound, high_bound)
            child2[i] = np.random.uniform(low_bound, high_bound)
        
        return child1, child2
    
    def _gaussian_mutation(self, individual: np.ndarray) -> np.ndarray:
        """Mutasi Gaussian"""
        mutated = individual.copy()
        for i in range(len(mutated)):
            if np.random.random() < self.mutation_rate:
                noise = np.random.normal(0, self.mutation_strength)
                mutated[i] += noise

                # Pastikan tetap dalam batas
                low, high = self.bounds[i]
                mutated[i] = np.clip(mutated[i], low, high)

        return mutated
    
    def evolve(self, generations: int) -> dict:
        """Loop evolusi utama"""
        for generation in range(generations):
            # Evaluasi kesesuaian
            fitness_values = np.array([self.fitness_func(ind)
                                     for ind in self.population])

            # Catat statistik
            self.fitness_history.append({
                'generation': generation,
                'best_fitness': np.max(fitness_values),
                'avg_fitness': np.mean(fitness_values),
                'worst_fitness': np.min(fitness_values)
            })

            # Seleksi turnamen
            new_population = []
            for _ in range(self.population_size // 2):
                # Pilih orangtua
                parent1_idx = self._tournament_selection(fitness_values)
                parent2_idx = self._tournament_selection(fitness_values)

                parent1 = self.population[parent1_idx]
                parent2 = self.population[parent2_idx]

                # Persilangan
                child1, child2 = self._blx_alpha_crossover(parent1, parent2)

                # Mutasi
                child1 = self._gaussian_mutation(child1)
                child2 = self._gaussian_mutation(child2)

                new_population.extend([child1, child2])

            self.population = np.array(new_population)

        # Evaluasi akhir
        final_fitness = np.array([self.fitness_func(ind)
                                for ind in self.population])
        best_idx = np.argmax(final_fitness)

        return {
            'best_individual': self.population[best_idx],
            'best_fitness': final_fitness[best_idx],
            'fitness_history': self.fitness_history
        }
    
    def _tournament_selection(self, fitness_values: np.ndarray, 
                            tournament_size: int = 3) -> int:
        """Tournament selection returning index"""
        tournament_indices = np.random.choice(len(fitness_values), 
                                            tournament_size, replace=False)
        tournament_fitness = fitness_values[tournament_indices]
        winner_idx = tournament_indices[np.argmax(tournament_fitness)]
        return winner_idx

# Example: Optimize Rastrigin function
def rastrigin_function(x):
    """Fungsi Rastrigin (masalah minimisasi)"""
    A = 10
    n = len(x)
    return -(A * n + np.sum(x**2 - A * np.cos(2 * np.pi * x)))

# Usage
bounds = [(-5.12, 5.12)] * 2  # 2D Rastrigin
ga = RealValuedGA(
    fitness_func=rastrigin_function,
    dimensions=2,
    bounds=bounds,
    population_size=100,
    mutation_strength=0.1
)

result = ga.evolve(generations=200)
print(f"Best solution: {result['best_individual']}")
print(f"Best fitness: {result['best_fitness']}")
\end{lstlisting}

\section{Algoritma Genetika untuk Traveling Salesman Problem}

\begin{lstlisting}[language=Python, caption=TSP dengan Algoritma Genetika]
import numpy as np
import matplotlib.pyplot as plt
from typing import List, Tuple

class TSP_GA:
    def __init__(self, 
                 cities: np.ndarray,
                 population_size: int = 100,
                 crossover_rate: float = 0.8,
                 mutation_rate: float = 0.02):
        
        self.cities = cities
        self.num_cities = len(cities)
        self.population_size = population_size
        self.crossover_rate = crossover_rate
        self.mutation_rate = mutation_rate
        
        # Create distance matrix
        self.distance_matrix = self._calculate_distance_matrix()
        
        # Initialize population
        self.population = self._initialize_population()
    
    def _calculate_distance_matrix(self) -> np.ndarray:
        """Hitung matriks jarak antar semua kota"""
        n = self.num_cities
        distances = np.zeros((n, n))

        for i in range(n):
            for j in range(n):
                if i != j:
                    distances[i][j] = np.sqrt(
                        (self.cities[i][0] - self.cities[j][0])**2 +
                        (self.cities[i][1] - self.cities[j][1])**2
                    )
        return distances
    
    def _initialize_population(self) -> List[List[int]]:
        """Inisialisasi populasi dengan permutasi acak"""
        population = []
        for _ in range(self.population_size):
            tour = list(range(self.num_cities))
            np.random.shuffle(tour)
            population.append(tour)
        return population
    
    def _calculate_tour_distance(self, tour: List[int]) -> float:
        """Hitung total jarak sebuah rute (tour)"""
        total_distance = 0
        for i in range(len(tour)):
            from_city = tour[i]
            to_city = tour[(i + 1) % len(tour)]
            total_distance += self.distance_matrix[from_city][to_city]
        return total_distance
    
    def _fitness(self, tour: List[int]) -> float:
        """Fungsi kesesuaian (invers jarak)"""
        distance = self._calculate_tour_distance(tour)
        return 1.0 / (1.0 + distance)
    
    def _order_crossover(self, parent1: List[int],
                        parent2: List[int]) -> Tuple[List[int], List[int]]:
        """Order crossover (OX)"""
        if np.random.random() > self.crossover_rate:
            return parent1.copy(), parent2.copy()

        size = len(parent1)
        start, end = sorted(np.random.choice(size, 2, replace=False))

        # Buat anak
        child1 = [None] * size
        child2 = [None] * size

        # Salin segmen
        child1[start:end] = parent1[start:end]
        child2[start:end] = parent2[start:end]

        # Isi posisi yang tersisa
        self._fill_remaining_ox(child1, parent2, start, end)
        self._fill_remaining_ox(child2, parent1, start, end)

        return child1, child2
    
    def _fill_remaining_ox(self, child: List[int], parent: List[int],
                          start: int, end: int):
        """Fungsi bantu untuk order crossover"""
        child_set = set(child[start:end])
        parent_filtered = [city for city in parent if city not in child_set]

        # Isi posisi sebelum start
        for i in range(start):
            child[i] = parent_filtered.pop(0)

        # Isi posisi setelah end
        for i in range(end, len(child)):
            child[i] = parent_filtered.pop(0)
    
    def _swap_mutation(self, tour: List[int]) -> List[int]:
        """Mutasi swap"""
        mutated = tour.copy()
        if np.random.random() < self.mutation_rate:
            i, j = np.random.choice(len(tour), 2, replace=False)
            mutated[i], mutated[j] = mutated[j], mutated[i]
        return mutated
    
    def _tournament_selection(self, fitness_values: List[float],
                            tournament_size: int = 3) -> int:
        """Seleksi turnamen"""
        tournament_indices = np.random.choice(len(fitness_values),
                                            tournament_size, replace=False)
        tournament_fitness = [fitness_values[i] for i in tournament_indices]
        winner_idx = tournament_indices[np.argmax(tournament_fitness)]
        return winner_idx
    
    def evolve(self, generations: int) -> dict:
        """Loop evolusi utama"""
        fitness_history = []
        best_tour = None
        best_distance = float('inf')

        for generation in range(generations):
            # Evaluasi kesesuaian
            fitness_values = [self._fitness(tour) for tour in self.population]
            distances = [self._calculate_tour_distance(tour)
                        for tour in self.population]

            # Lacak solusi terbaik
            min_distance_idx = np.argmin(distances)
            if distances[min_distance_idx] < best_distance:
                best_distance = distances[min_distance_idx]
                best_tour = self.population[min_distance_idx].copy()

            # Catat statistik
            fitness_history.append({
                'generation': generation,
                'best_distance': np.min(distances),
                'avg_distance': np.mean(distances),
                'worst_distance': np.max(distances)
            })

            # Buat populasi baru
            new_population = []

            # Elitisme: simpan individu terbaik
            new_population.append(best_tour.copy())

            # Hasilkan sisa populasi
            while len(new_population) < self.population_size:
                # Seleksi
                parent1_idx = self._tournament_selection(fitness_values)
                parent2_idx = self._tournament_selection(fitness_values)

                parent1 = self.population[parent1_idx]
                parent2 = self.population[parent2_idx]

                # Persilangan
                child1, child2 = self._order_crossover(parent1, parent2)

                # Mutasi
                child1 = self._swap_mutation(child1)
                child2 = self._swap_mutation(child2)

                new_population.extend([child1, child2])

            # Pangkas sesuai ukuran populasi
            self.population = new_population[:self.population_size]

        return {
            'best_tour': best_tour,
            'best_distance': best_distance,
            'fitness_history': fitness_history
        }
    
    def plot_tour(self, tour: List[int], title: str = "Rute Terbaik"):
        """Plot rute (tour)"""
        plt.figure(figsize=(10, 8))

        # Plot kota-kota
        plt.scatter(self.cities[:, 0], self.cities[:, 1],
                   c='red', s=100, zorder=2)

        # Plot rute
        tour_cities = self.cities[tour + [tour[0]]]  # Tutup loop
        plt.plot(tour_cities[:, 0], tour_cities[:, 1],
                'b-', linewidth=2, zorder=1)

        # Tambahkan label kota
        for i, city in enumerate(self.cities):
            plt.annotate(str(i), (city[0], city[1]),
                        xytext=(5, 5), textcoords='offset points')

        plt.title(f"{title}\nJarak: {self._calculate_tour_distance(tour):.2f}")
        plt.xlabel("Koordinat X")
        plt.ylabel("Koordinat Y")
        plt.grid(True, alpha=0.3)
        plt.show()

# Example usage
if __name__ == "__main__":
    # Buat kota acak
    np.random.seed(42)
    num_cities = 20
    cities = np.random.rand(num_cities, 2) * 100

    # Inisialisasi dan jalankan GA
    tsp_ga = TSP_GA(cities, population_size=100, mutation_rate=0.02)
    result = tsp_ga.evolve(generations=500)

    print(f"Jarak terbaik: {result['best_distance']:.2f}")
    print(f"Rute terbaik: {result['best_tour']}")

    # Plot rute terbaik
    tsp_ga.plot_tour(result['best_tour'])
\end{lstlisting}

\section{NSGA-II untuk Optimisasi Multi-Objektif}

\begin{lstlisting}[language=Python, caption=Implementasi NSGA-II]
import numpy as np
from typing import List, Tuple

class NSGA2:
    def __init__(self, 
                 objective_functions: List,
                 num_variables: int,
                 bounds: List[Tuple[float, float]],
                 population_size: int = 100,
                 crossover_rate: float = 0.9,
                 mutation_rate: float = 0.1):
        
        self.objective_functions = objective_functions
        self.num_objectives = len(objective_functions)
        self.num_variables = num_variables
        self.bounds = bounds
        self.population_size = population_size
        self.crossover_rate = crossover_rate
        self.mutation_rate = mutation_rate
        
        # Ensure even population size
        if self.population_size % 2 != 0:
            self.population_size += 1
    
    def _initialize_population(self) -> np.ndarray:
        """Inisialisasi populasi acak"""
        population = np.zeros((self.population_size, self.num_variables))
        for i in range(self.num_variables):
            low, high = self.bounds[i]
            population[:, i] = np.random.uniform(low, high, self.population_size)
        return population
    
    def _evaluate_objectives(self, population: np.ndarray) -> np.ndarray:
        """Evaluasi semua fungsi objektif untuk populasi"""
        objectives = np.zeros((len(population), self.num_objectives))
        for i, individual in enumerate(population):
            for j, obj_func in enumerate(self.objective_functions):
                objectives[i, j] = obj_func(individual)
        return objectives
    
    def _dominates(self, obj1: np.ndarray, obj2: np.ndarray) -> bool:
        """Periksa apakah obj1 mendominasi obj2 (mengasumsikan minimisasi)"""
        return np.all(obj1 <= obj2) and np.any(obj1 < obj2)
    
    def _fast_non_dominated_sort(self, objectives: np.ndarray) -> Tuple[List[List[int]], np.ndarray]:
        """Penyortiran non-dominated cepat"""
        population_size = len(objectives)
        domination_count = np.zeros(population_size)
        dominated_solutions = [[] for _ in range(population_size)]
        fronts = [[]]
        
        # Find domination relationships
        for i in range(population_size):
            for j in range(population_size):
                if i != j:
                    if self._dominates(objectives[i], objectives[j]):
                        dominated_solutions[i].append(j)
                    elif self._dominates(objectives[j], objectives[i]):
                        domination_count[i] += 1
            
            if domination_count[i] == 0:
                fronts[0].append(i)
        
        # Build subsequent fronts
        current_front = 0
        while len(fronts[current_front]) > 0:
            next_front = []
            for i in fronts[current_front]:
                for j in dominated_solutions[i]:
                    domination_count[j] -= 1
                    if domination_count[j] == 0:
                        next_front.append(j)
            current_front += 1
            fronts.append(next_front)
        
        # Remove empty last front
        fronts.pop()
        
        # Assign ranks
        ranks = np.zeros(population_size)
        for rank, front in enumerate(fronts):
            for individual in front:
                ranks[individual] = rank
        
        return fronts, ranks
    
    def _calculate_crowding_distance(self, objectives: np.ndarray,
                                   front: List[int]) -> np.ndarray:
        """Hitung crowding distance untuk individu dalam sebuah front"""
        if len(front) <= 2:
            return np.full(len(front), float('inf'))
        
        distances = np.zeros(len(front))
        
        for obj_idx in range(self.num_objectives):
            # Sort by objective value
            sorted_indices = sorted(range(len(front)), 
                                  key=lambda x: objectives[front[x], obj_idx])
            
            # Set boundary points to infinity
            distances[sorted_indices[0]] = float('inf')
            distances[sorted_indices[-1]] = float('inf')
            
            # Calculate distances for middle points
            obj_range = (objectives[front[sorted_indices[-1]], obj_idx] - 
                        objectives[front[sorted_indices[0]], obj_idx])
            
            if obj_range > 0:
                for i in range(1, len(sorted_indices) - 1):
                    distance = (objectives[front[sorted_indices[i + 1]], obj_idx] - 
                              objectives[front[sorted_indices[i - 1]], obj_idx])
                    distances[sorted_indices[i]] += distance / obj_range
        
        return distances
    
    def _tournament_selection(self, ranks: np.ndarray,
                            crowding_distances: np.ndarray,
                            population_size: int) -> List[int]:
        """Seleksi turnamen biner berdasarkan rank dan crowding distance"""
        selected = []
        
        for _ in range(population_size):
            # Select two random individuals
            candidates = np.random.choice(len(ranks), 2, replace=False)
            i, j = candidates[0], candidates[1]
            
            # Compare based on rank first, then crowding distance
            if ranks[i] < ranks[j]:
                selected.append(i)
            elif ranks[i] > ranks[j]:
                selected.append(j)
            else:  # Same rank, compare crowding distance
                if crowding_distances[i] > crowding_distances[j]:
                    selected.append(i)
                else:
                    selected.append(j)
        
        return selected
    
    def _sbx_crossover(self, parent1: np.ndarray, parent2: np.ndarray,
                      eta: float = 20.0) -> Tuple[np.ndarray, np.ndarray]:
        """Simulated Binary Crossover (SBX)"""
        if np.random.random() > self.crossover_rate:
            return parent1.copy(), parent2.copy()
        
        child1 = np.zeros_like(parent1)
        child2 = np.zeros_like(parent2)
        
        for i in range(len(parent1)):
            if np.random.random() <= 0.5:
                if abs(parent1[i] - parent2[i]) > 1e-14:
                    y1, y2 = min(parent1[i], parent2[i]), max(parent1[i], parent2[i])
                    
                    # Calculate beta
                    rand = np.random.random()
                    if rand <= 0.5:
                        beta = (2 * rand) ** (1.0 / (eta + 1))
                    else:
                        beta = (1.0 / (2 * (1 - rand))) ** (1.0 / (eta + 1))
                    
                    child1[i] = 0.5 * ((y1 + y2) - beta * (y2 - y1))
                    child2[i] = 0.5 * ((y1 + y2) + beta * (y2 - y1))
                    
                    # Ensure bounds
                    low, high = self.bounds[i]
                    child1[i] = np.clip(child1[i], low, high)
                    child2[i] = np.clip(child2[i], low, high)
                else:
                    child1[i] = parent1[i]
                    child2[i] = parent2[i]
            else:
                child1[i] = parent1[i]
                child2[i] = parent2[i]
        
        return child1, child2
    
    def _polynomial_mutation(self, individual: np.ndarray,
                           eta: float = 20.0) -> np.ndarray:
        """Mutasi polinomial"""
        mutated = individual.copy()
        
        for i in range(len(mutated)):
            if np.random.random() < self.mutation_rate:
                low, high = self.bounds[i]
                delta1 = (mutated[i] - low) / (high - low)
                delta2 = (high - mutated[i]) / (high - low)
                
                rand = np.random.random()
                mut_pow = 1.0 / (eta + 1.0)
                
                if rand <= 0.5:
                    xy = 1.0 - delta1
                    val = 2.0 * rand + (1.0 - 2.0 * rand) * (xy ** (eta + 1.0))
                    deltaq = val ** mut_pow - 1.0
                else:
                    xy = 1.0 - delta2
                    val = 2.0 * (1.0 - rand) + 2.0 * (rand - 0.5) * (xy ** (eta + 1.0))
                    deltaq = 1.0 - val ** mut_pow
                
                mutated[i] += deltaq * (high - low)
                mutated[i] = np.clip(mutated[i], low, high)
        
        return mutated
    
    def evolve(self, generations: int) -> dict:
        """Loop evolusi NSGA-II utama"""
        # Inisialisasi populasi
        population = self._initialize_population()

        for generation in range(generations):
            # Evaluasi objektif
            objectives = self._evaluate_objectives(population)

            # Penyortiran non-dominated
            fronts, ranks = self._fast_non_dominated_sort(objectives)

            # Hitung crowding distances
            crowding_distances = np.zeros(len(population))
            for front in fronts:
                if len(front) > 0:
                    distances = self._calculate_crowding_distance(objectives, front)
                    for i, individual_idx in enumerate(front):
                        crowding_distances[individual_idx] = distances[i]

            # Seleksi untuk mating pool
            mating_pool_indices = self._tournament_selection(ranks, crowding_distances,
                                                           self.population_size)
            mating_pool = population[mating_pool_indices]

            # Buat keturunan melalui persilangan dan mutasi
            offspring = []
            for i in range(0, self.population_size, 2):
                parent1 = mating_pool[i]
                parent2 = mating_pool[i + 1]

                child1, child2 = self._sbx_crossover(parent1, parent2)
                child1 = self._polynomial_mutation(child1)
                child2 = self._polynomial_mutation(child2)

                offspring.extend([child1, child2])

            offspring = np.array(offspring)

            # Gabungkan populasi orangtua dan keturunan
            combined_population = np.vstack([population, offspring])
            combined_objectives = self._evaluate_objectives(combined_population)

            # Seleksi lingkungan
            combined_fronts, combined_ranks = self._fast_non_dominated_sort(combined_objectives)

            new_population = []
            front_idx = 0

            # Tambah front lengkap
            while (len(new_population) + len(combined_fronts[front_idx]) <= self.population_size):
                for individual_idx in combined_fronts[front_idx]:
                    new_population.append(individual_idx)
                front_idx += 1

                if front_idx >= len(combined_fronts):
                    break

            # Tambah front parsial jika diperlukan
            if len(new_population) < self.population_size and front_idx < len(combined_fronts):
                last_front = combined_fronts[front_idx]
                crowding_distances = self._calculate_crowding_distance(combined_objectives, last_front)

                # Urutkan berdasarkan crowding distance (menurun)
                sorted_indices = sorted(range(len(last_front)),
                                      key=lambda x: crowding_distances[x], reverse=True)

                remaining_slots = self.population_size - len(new_population)
                for i in range(remaining_slots):
                    new_population.append(last_front[sorted_indices[i]])

            # Perbarui populasi
            population = combined_population[new_population]

        # Evaluasi akhir dan kembalikan front Pareto
        final_objectives = self._evaluate_objectives(population)
        fronts, _ = self._fast_non_dominated_sort(final_objectives)

        pareto_front_indices = fronts[0]
        pareto_front_solutions = population[pareto_front_indices]
        pareto_front_objectives = final_objectives[pareto_front_indices]

        return {
            'pareto_front_solutions': pareto_front_solutions,
            'pareto_front_objectives': pareto_front_objectives,
            'final_population': population,
            'final_objectives': final_objectives
        }

# Example: Minimize two objectives (ZDT1 problem)
def objective1(x):
    return x[0]

def objective2(x):
    g = 1 + 9 * np.sum(x[1:]) / (len(x) - 1)
    h = 1 - np.sqrt(x[0] / g)
    return g * h

# Usage
if __name__ == "__main__":
    objectives = [objective1, objective2]
    bounds = [(0, 1)] * 10  # 10-dimensi

    nsga2 = NSGA2(objectives, 10, bounds, population_size=100)
    result = nsga2.evolve(generations=250)

    # Plot front Pareto
    pareto_objectives = result['pareto_front_objectives']
    plt.figure(figsize=(10, 6))
    plt.scatter(pareto_objectives[:, 0], pareto_objectives[:, 1],
               c='red', alpha=0.7)
    plt.xlabel('Objektif 1')
    plt.ylabel('Objektif 2')
    plt.title('Front Pareto')
    plt.grid(True, alpha=0.3)
    plt.show()
\end{lstlisting}