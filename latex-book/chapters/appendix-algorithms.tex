\chapter{Algorithm Implementations}

\section{Basic Genetic Algorithm Implementation}

\subsection{Python Implementation}

\begin{lstlisting}[language=Python, caption=Basic Genetic Algorithm in Python]
import numpy as np
import matplotlib.pyplot as plt
from typing import List, Tuple, Callable

class GeneticAlgorithm:
    def __init__(self, 
                 fitness_func: Callable,
                 chromosome_length: int,
                 population_size: int = 100,
                 crossover_rate: float = 0.8,
                 mutation_rate: float = 0.01,
                 elitism: bool = True):
        
        self.fitness_func = fitness_func
        self.chromosome_length = chromosome_length
        self.population_size = population_size
        self.crossover_rate = crossover_rate
        self.mutation_rate = mutation_rate
        self.elitism = elitism
        
        # Initialize population
        self.population = self._initialize_population()
        self.fitness_history = []
        self.best_individual = None
        self.best_fitness = float('-inf')
    
    def _initialize_population(self) -> np.ndarray:
        """Initialize random binary population"""
        return np.random.randint(0, 2, 
                               (self.population_size, self.chromosome_length))
    
    def _evaluate_fitness(self, population: np.ndarray) -> np.ndarray:
        """Evaluate fitness for all individuals"""
        fitness_values = np.array([self.fitness_func(individual) 
                                 for individual in population])
        return fitness_values
    
    def _tournament_selection(self, population: np.ndarray, 
                            fitness_values: np.ndarray, 
                            tournament_size: int = 3) -> np.ndarray:
        """Tournament selection"""
        selected = []
        for _ in range(len(population)):
            # Select random individuals for tournament
            tournament_indices = np.random.choice(len(population), 
                                                tournament_size, 
                                                replace=False)
            tournament_fitness = fitness_values[tournament_indices]
            
            # Select winner
            winner_index = tournament_indices[np.argmax(tournament_fitness)]
            selected.append(population[winner_index])
        
        return np.array(selected)
    
    def _one_point_crossover(self, parent1: np.ndarray, 
                           parent2: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:
        """One-point crossover"""
        if np.random.random() > self.crossover_rate:
            return parent1.copy(), parent2.copy()
        
        crossover_point = np.random.randint(1, len(parent1))
        
        child1 = np.concatenate([parent1[:crossover_point], 
                               parent2[crossover_point:]])
        child2 = np.concatenate([parent2[:crossover_point], 
                               parent1[crossover_point:]])
        
        return child1, child2
    
    def _bit_flip_mutation(self, individual: np.ndarray) -> np.ndarray:
        """Bit-flip mutation"""
        mutated = individual.copy()
        for i in range(len(mutated)):
            if np.random.random() < self.mutation_rate:
                mutated[i] = 1 - mutated[i]  # Flip bit
        return mutated
    
    def _apply_elitism(self, old_population: np.ndarray, 
                      old_fitness: np.ndarray,
                      new_population: np.ndarray) -> np.ndarray:
        """Apply elitism by preserving best individual"""
        if not self.elitism:
            return new_population
        
        best_index = np.argmax(old_fitness)
        best_individual = old_population[best_index]
        
        # Replace worst individual in new population with best from old
        new_fitness = self._evaluate_fitness(new_population)
        worst_index = np.argmin(new_fitness)
        new_population[worst_index] = best_individual
        
        return new_population
    
    def evolve(self, generations: int) -> dict:
        """Main evolutionary loop"""
        for generation in range(generations):
            # Evaluate fitness
            fitness_values = self._evaluate_fitness(self.population)
            
            # Track best individual
            max_fitness_idx = np.argmax(fitness_values)
            if fitness_values[max_fitness_idx] > self.best_fitness:
                self.best_fitness = fitness_values[max_fitness_idx]
                self.best_individual = self.population[max_fitness_idx].copy()
            
            # Record statistics
            self.fitness_history.append({
                'generation': generation,
                'best_fitness': np.max(fitness_values),
                'avg_fitness': np.mean(fitness_values),
                'worst_fitness': np.min(fitness_values)
            })
            
            # Selection
            selected = self._tournament_selection(self.population, fitness_values)
            
            # Crossover and mutation
            new_population = []
            for i in range(0, len(selected), 2):
                parent1 = selected[i]
                parent2 = selected[(i + 1) % len(selected)]
                
                # Crossover
                child1, child2 = self._one_point_crossover(parent1, parent2)
                
                # Mutation
                child1 = self._bit_flip_mutation(child1)
                child2 = self._bit_flip_mutation(child2)
                
                new_population.extend([child1, child2])
            
            new_population = np.array(new_population[:self.population_size])
            
            # Apply elitism
            self.population = self._apply_elitism(self.population, 
                                                fitness_values,
                                                new_population)
        
        return {
            'best_individual': self.best_individual,
            'best_fitness': self.best_fitness,
            'fitness_history': self.fitness_history
        }
    
    def plot_fitness_history(self):
        """Plot fitness evolution over generations"""
        generations = [entry['generation'] for entry in self.fitness_history]
        best_fitness = [entry['best_fitness'] for entry in self.fitness_history]
        avg_fitness = [entry['avg_fitness'] for entry in self.fitness_history]
        
        plt.figure(figsize=(10, 6))
        plt.plot(generations, best_fitness, label='Best Fitness', linewidth=2)
        plt.plot(generations, avg_fitness, label='Average Fitness', linewidth=2)
        plt.xlabel('Generation')
        plt.ylabel('Fitness')
        plt.title('Fitness Evolution')
        plt.legend()
        plt.grid(True, alpha=0.3)
        plt.show()

# Example usage
def onemax_fitness(individual):
    """OneMax problem: maximize number of 1s"""
    return np.sum(individual)

def sphere_function_binary(individual, bounds=(-5.12, 5.12)):
    """Sphere function with binary encoding"""
    # Decode binary to real values
    x = bounds[0] + (bounds[1] - bounds[0]) * np.sum(individual * 2**np.arange(len(individual))[::-1]) / (2**len(individual) - 1)
    return -(x**2)  # Negative because we want to minimize

# Run GA on OneMax problem
if __name__ == "__main__":
    ga = GeneticAlgorithm(
        fitness_func=onemax_fitness,
        chromosome_length=20,
        population_size=50,
        crossover_rate=0.8,
        mutation_rate=0.01
    )
    
    result = ga.evolve(generations=100)
    
    print(f"Best individual: {result['best_individual']}")
    print(f"Best fitness: {result['best_fitness']}")
    
    ga.plot_fitness_history()
\end{lstlisting}

\section{Real-Valued Genetic Algorithm}

\begin{lstlisting}[language=Python, caption=Real-Valued GA Implementation]
import numpy as np
from typing import List, Tuple, Callable

class RealValuedGA:
    def __init__(self, 
                 fitness_func: Callable,
                 dimensions: int,
                 bounds: List[Tuple[float, float]],
                 population_size: int = 100,
                 crossover_rate: float = 0.8,
                 mutation_rate: float = 0.1,
                 mutation_strength: float = 0.1):
        
        self.fitness_func = fitness_func
        self.dimensions = dimensions
        self.bounds = bounds
        self.population_size = population_size
        self.crossover_rate = crossover_rate
        self.mutation_rate = mutation_rate
        self.mutation_strength = mutation_strength
        
        self.population = self._initialize_population()
        self.fitness_history = []
    
    def _initialize_population(self) -> np.ndarray:
        """Initialize random real-valued population"""
        population = np.zeros((self.population_size, self.dimensions))
        for i in range(self.dimensions):
            low, high = self.bounds[i]
            population[:, i] = np.random.uniform(low, high, self.population_size)
        return population
    
    def _blx_alpha_crossover(self, parent1: np.ndarray, 
                           parent2: np.ndarray, 
                           alpha: float = 0.5) -> Tuple[np.ndarray, np.ndarray]:
        """BLX-alpha crossover"""
        if np.random.random() > self.crossover_rate:
            return parent1.copy(), parent2.copy()
        
        child1 = np.zeros_like(parent1)
        child2 = np.zeros_like(parent2)
        
        for i in range(len(parent1)):
            min_val = min(parent1[i], parent2[i])
            max_val = max(parent1[i], parent2[i])
            interval = max_val - min_val
            
            low_bound = max(min_val - alpha * interval, self.bounds[i][0])
            high_bound = min(max_val + alpha * interval, self.bounds[i][1])
            
            child1[i] = np.random.uniform(low_bound, high_bound)
            child2[i] = np.random.uniform(low_bound, high_bound)
        
        return child1, child2
    
    def _gaussian_mutation(self, individual: np.ndarray) -> np.ndarray:
        """Gaussian mutation"""
        mutated = individual.copy()
        for i in range(len(mutated)):
            if np.random.random() < self.mutation_rate:
                noise = np.random.normal(0, self.mutation_strength)
                mutated[i] += noise
                
                # Ensure bounds are respected
                low, high = self.bounds[i]
                mutated[i] = np.clip(mutated[i], low, high)
        
        return mutated
    
    def evolve(self, generations: int) -> dict:
        """Main evolutionary loop"""
        for generation in range(generations):
            # Evaluate fitness
            fitness_values = np.array([self.fitness_func(ind) 
                                     for ind in self.population])
            
            # Record statistics
            self.fitness_history.append({
                'generation': generation,
                'best_fitness': np.max(fitness_values),
                'avg_fitness': np.mean(fitness_values),
                'worst_fitness': np.min(fitness_values)
            })
            
            # Tournament selection
            new_population = []
            for _ in range(self.population_size // 2):
                # Select parents
                parent1_idx = self._tournament_selection(fitness_values)
                parent2_idx = self._tournament_selection(fitness_values)
                
                parent1 = self.population[parent1_idx]
                parent2 = self.population[parent2_idx]
                
                # Crossover
                child1, child2 = self._blx_alpha_crossover(parent1, parent2)
                
                # Mutation
                child1 = self._gaussian_mutation(child1)
                child2 = self._gaussian_mutation(child2)
                
                new_population.extend([child1, child2])
            
            self.population = np.array(new_population)
        
        # Final evaluation
        final_fitness = np.array([self.fitness_func(ind) 
                                for ind in self.population])
        best_idx = np.argmax(final_fitness)
        
        return {
            'best_individual': self.population[best_idx],
            'best_fitness': final_fitness[best_idx],
            'fitness_history': self.fitness_history
        }
    
    def _tournament_selection(self, fitness_values: np.ndarray, 
                            tournament_size: int = 3) -> int:
        """Tournament selection returning index"""
        tournament_indices = np.random.choice(len(fitness_values), 
                                            tournament_size, replace=False)
        tournament_fitness = fitness_values[tournament_indices]
        winner_idx = tournament_indices[np.argmax(tournament_fitness)]
        return winner_idx

# Example: Optimize Rastrigin function
def rastrigin_function(x):
    """Rastrigin function (minimization problem)"""
    A = 10
    n = len(x)
    return -(A * n + np.sum(x**2 - A * np.cos(2 * np.pi * x)))

# Usage
bounds = [(-5.12, 5.12)] * 2  # 2D Rastrigin
ga = RealValuedGA(
    fitness_func=rastrigin_function,
    dimensions=2,
    bounds=bounds,
    population_size=100,
    mutation_strength=0.1
)

result = ga.evolve(generations=200)
print(f"Best solution: {result['best_individual']}")
print(f"Best fitness: {result['best_fitness']}")
\end{lstlisting}

\section{Traveling Salesman Problem GA}

\begin{lstlisting}[language=Python, caption=TSP with Genetic Algorithm]
import numpy as np
import matplotlib.pyplot as plt
from typing import List, Tuple

class TSP_GA:
    def __init__(self, 
                 cities: np.ndarray,
                 population_size: int = 100,
                 crossover_rate: float = 0.8,
                 mutation_rate: float = 0.02):
        
        self.cities = cities
        self.num_cities = len(cities)
        self.population_size = population_size
        self.crossover_rate = crossover_rate
        self.mutation_rate = mutation_rate
        
        # Create distance matrix
        self.distance_matrix = self._calculate_distance_matrix()
        
        # Initialize population
        self.population = self._initialize_population()
    
    def _calculate_distance_matrix(self) -> np.ndarray:
        """Calculate distance matrix between all cities"""
        n = self.num_cities
        distances = np.zeros((n, n))
        
        for i in range(n):
            for j in range(n):
                if i != j:
                    distances[i][j] = np.sqrt(
                        (self.cities[i][0] - self.cities[j][0])**2 + 
                        (self.cities[i][1] - self.cities[j][1])**2
                    )
        return distances
    
    def _initialize_population(self) -> List[List[int]]:
        """Initialize population with random permutations"""
        population = []
        for _ in range(self.population_size):
            tour = list(range(self.num_cities))
            np.random.shuffle(tour)
            population.append(tour)
        return population
    
    def _calculate_tour_distance(self, tour: List[int]) -> float:
        """Calculate total distance of a tour"""
        total_distance = 0
        for i in range(len(tour)):
            from_city = tour[i]
            to_city = tour[(i + 1) % len(tour)]
            total_distance += self.distance_matrix[from_city][to_city]
        return total_distance
    
    def _fitness(self, tour: List[int]) -> float:
        """Fitness function (inverse of distance)"""
        distance = self._calculate_tour_distance(tour)
        return 1.0 / (1.0 + distance)
    
    def _order_crossover(self, parent1: List[int], 
                        parent2: List[int]) -> Tuple[List[int], List[int]]:
        """Order crossover (OX)"""
        if np.random.random() > self.crossover_rate:
            return parent1.copy(), parent2.copy()
        
        size = len(parent1)
        start, end = sorted(np.random.choice(size, 2, replace=False))
        
        # Create children
        child1 = [None] * size
        child2 = [None] * size
        
        # Copy segments
        child1[start:end] = parent1[start:end]
        child2[start:end] = parent2[start:end]
        
        # Fill remaining positions
        self._fill_remaining_ox(child1, parent2, start, end)
        self._fill_remaining_ox(child2, parent1, start, end)
        
        return child1, child2
    
    def _fill_remaining_ox(self, child: List[int], parent: List[int], 
                          start: int, end: int):
        """Helper function for order crossover"""
        child_set = set(child[start:end])
        parent_filtered = [city for city in parent if city not in child_set]
        
        # Fill positions before start
        for i in range(start):
            child[i] = parent_filtered.pop(0)
        
        # Fill positions after end
        for i in range(end, len(child)):
            child[i] = parent_filtered.pop(0)
    
    def _swap_mutation(self, tour: List[int]) -> List[int]:
        """Swap mutation"""
        mutated = tour.copy()
        if np.random.random() < self.mutation_rate:
            i, j = np.random.choice(len(tour), 2, replace=False)
            mutated[i], mutated[j] = mutated[j], mutated[i]
        return mutated
    
    def _tournament_selection(self, fitness_values: List[float], 
                            tournament_size: int = 3) -> int:
        """Tournament selection"""
        tournament_indices = np.random.choice(len(fitness_values), 
                                            tournament_size, replace=False)
        tournament_fitness = [fitness_values[i] for i in tournament_indices]
        winner_idx = tournament_indices[np.argmax(tournament_fitness)]
        return winner_idx
    
    def evolve(self, generations: int) -> dict:
        """Main evolutionary loop"""
        fitness_history = []
        best_tour = None
        best_distance = float('inf')
        
        for generation in range(generations):
            # Evaluate fitness
            fitness_values = [self._fitness(tour) for tour in self.population]
            distances = [self._calculate_tour_distance(tour) 
                        for tour in self.population]
            
            # Track best solution
            min_distance_idx = np.argmin(distances)
            if distances[min_distance_idx] < best_distance:
                best_distance = distances[min_distance_idx]
                best_tour = self.population[min_distance_idx].copy()
            
            # Record statistics
            fitness_history.append({
                'generation': generation,
                'best_distance': np.min(distances),
                'avg_distance': np.mean(distances),
                'worst_distance': np.max(distances)
            })
            
            # Create new population
            new_population = []
            
            # Elitism: keep best individual
            new_population.append(best_tour.copy())
            
            # Generate rest of population
            while len(new_population) < self.population_size:
                # Selection
                parent1_idx = self._tournament_selection(fitness_values)
                parent2_idx = self._tournament_selection(fitness_values)
                
                parent1 = self.population[parent1_idx]
                parent2 = self.population[parent2_idx]
                
                # Crossover
                child1, child2 = self._order_crossover(parent1, parent2)
                
                # Mutation
                child1 = self._swap_mutation(child1)
                child2 = self._swap_mutation(child2)
                
                new_population.extend([child1, child2])
            
            # Trim to population size
            self.population = new_population[:self.population_size]
        
        return {
            'best_tour': best_tour,
            'best_distance': best_distance,
            'fitness_history': fitness_history
        }
    
    def plot_tour(self, tour: List[int], title: str = "Best Tour"):
        """Plot the tour"""
        plt.figure(figsize=(10, 8))
        
        # Plot cities
        plt.scatter(self.cities[:, 0], self.cities[:, 1], 
                   c='red', s=100, zorder=2)
        
        # Plot tour
        tour_cities = self.cities[tour + [tour[0]]]  # Close the loop
        plt.plot(tour_cities[:, 0], tour_cities[:, 1], 
                'b-', linewidth=2, zorder=1)
        
        # Add city labels
        for i, city in enumerate(self.cities):
            plt.annotate(str(i), (city[0], city[1]), 
                        xytext=(5, 5), textcoords='offset points')
        
        plt.title(f"{title}\nDistance: {self._calculate_tour_distance(tour):.2f}")
        plt.xlabel("X Coordinate")
        plt.ylabel("Y Coordinate")
        plt.grid(True, alpha=0.3)
        plt.show()

# Example usage
if __name__ == "__main__":
    # Create random cities
    np.random.seed(42)
    num_cities = 20
    cities = np.random.rand(num_cities, 2) * 100
    
    # Initialize and run GA
    tsp_ga = TSP_GA(cities, population_size=100, mutation_rate=0.02)
    result = tsp_ga.evolve(generations=500)
    
    print(f"Best distance: {result['best_distance']:.2f}")
    print(f"Best tour: {result['best_tour']}")
    
    # Plot best tour
    tsp_ga.plot_tour(result['best_tour'])
\end{lstlisting}

\section{NSGA-II for Multi-Objective Optimization}

\begin{lstlisting}[language=Python, caption=NSGA-II Implementation]
import numpy as np
from typing import List, Tuple

class NSGA2:
    def __init__(self, 
                 objective_functions: List,
                 num_variables: int,
                 bounds: List[Tuple[float, float]],
                 population_size: int = 100,
                 crossover_rate: float = 0.9,
                 mutation_rate: float = 0.1):
        
        self.objective_functions = objective_functions
        self.num_objectives = len(objective_functions)
        self.num_variables = num_variables
        self.bounds = bounds
        self.population_size = population_size
        self.crossover_rate = crossover_rate
        self.mutation_rate = mutation_rate
        
        # Ensure even population size
        if self.population_size % 2 != 0:
            self.population_size += 1
    
    def _initialize_population(self) -> np.ndarray:
        """Initialize random population"""
        population = np.zeros((self.population_size, self.num_variables))
        for i in range(self.num_variables):
            low, high = self.bounds[i]
            population[:, i] = np.random.uniform(low, high, self.population_size)
        return population
    
    def _evaluate_objectives(self, population: np.ndarray) -> np.ndarray:
        """Evaluate all objectives for population"""
        objectives = np.zeros((len(population), self.num_objectives))
        for i, individual in enumerate(population):
            for j, obj_func in enumerate(self.objective_functions):
                objectives[i, j] = obj_func(individual)
        return objectives
    
    def _dominates(self, obj1: np.ndarray, obj2: np.ndarray) -> bool:
        """Check if obj1 dominates obj2 (assuming minimization)"""
        return np.all(obj1 <= obj2) and np.any(obj1 < obj2)
    
    def _fast_non_dominated_sort(self, objectives: np.ndarray) -> Tuple[List[List[int]], np.ndarray]:
        """Fast non-dominated sorting"""
        population_size = len(objectives)
        domination_count = np.zeros(population_size)
        dominated_solutions = [[] for _ in range(population_size)]
        fronts = [[]]
        
        # Find domination relationships
        for i in range(population_size):
            for j in range(population_size):
                if i != j:
                    if self._dominates(objectives[i], objectives[j]):
                        dominated_solutions[i].append(j)
                    elif self._dominates(objectives[j], objectives[i]):
                        domination_count[i] += 1
            
            if domination_count[i] == 0:
                fronts[0].append(i)
        
        # Build subsequent fronts
        current_front = 0
        while len(fronts[current_front]) > 0:
            next_front = []
            for i in fronts[current_front]:
                for j in dominated_solutions[i]:
                    domination_count[j] -= 1
                    if domination_count[j] == 0:
                        next_front.append(j)
            current_front += 1
            fronts.append(next_front)
        
        # Remove empty last front
        fronts.pop()
        
        # Assign ranks
        ranks = np.zeros(population_size)
        for rank, front in enumerate(fronts):
            for individual in front:
                ranks[individual] = rank
        
        return fronts, ranks
    
    def _calculate_crowding_distance(self, objectives: np.ndarray, 
                                   front: List[int]) -> np.ndarray:
        """Calculate crowding distance for individuals in a front"""
        if len(front) <= 2:
            return np.full(len(front), float('inf'))
        
        distances = np.zeros(len(front))
        
        for obj_idx in range(self.num_objectives):
            # Sort by objective value
            sorted_indices = sorted(range(len(front)), 
                                  key=lambda x: objectives[front[x], obj_idx])
            
            # Set boundary points to infinity
            distances[sorted_indices[0]] = float('inf')
            distances[sorted_indices[-1]] = float('inf')
            
            # Calculate distances for middle points
            obj_range = (objectives[front[sorted_indices[-1]], obj_idx] - 
                        objectives[front[sorted_indices[0]], obj_idx])
            
            if obj_range > 0:
                for i in range(1, len(sorted_indices) - 1):
                    distance = (objectives[front[sorted_indices[i + 1]], obj_idx] - 
                              objectives[front[sorted_indices[i - 1]], obj_idx])
                    distances[sorted_indices[i]] += distance / obj_range
        
        return distances
    
    def _tournament_selection(self, ranks: np.ndarray, 
                            crowding_distances: np.ndarray,
                            population_size: int) -> List[int]:
        """Binary tournament selection based on rank and crowding distance"""
        selected = []
        
        for _ in range(population_size):
            # Select two random individuals
            candidates = np.random.choice(len(ranks), 2, replace=False)
            i, j = candidates[0], candidates[1]
            
            # Compare based on rank first, then crowding distance
            if ranks[i] < ranks[j]:
                selected.append(i)
            elif ranks[i] > ranks[j]:
                selected.append(j)
            else:  # Same rank, compare crowding distance
                if crowding_distances[i] > crowding_distances[j]:
                    selected.append(i)
                else:
                    selected.append(j)
        
        return selected
    
    def _sbx_crossover(self, parent1: np.ndarray, parent2: np.ndarray, 
                      eta: float = 20.0) -> Tuple[np.ndarray, np.ndarray]:
        """Simulated Binary Crossover (SBX)"""
        if np.random.random() > self.crossover_rate:
            return parent1.copy(), parent2.copy()
        
        child1 = np.zeros_like(parent1)
        child2 = np.zeros_like(parent2)
        
        for i in range(len(parent1)):
            if np.random.random() <= 0.5:
                if abs(parent1[i] - parent2[i]) > 1e-14:
                    y1, y2 = min(parent1[i], parent2[i]), max(parent1[i], parent2[i])
                    
                    # Calculate beta
                    rand = np.random.random()
                    if rand <= 0.5:
                        beta = (2 * rand) ** (1.0 / (eta + 1))
                    else:
                        beta = (1.0 / (2 * (1 - rand))) ** (1.0 / (eta + 1))
                    
                    child1[i] = 0.5 * ((y1 + y2) - beta * (y2 - y1))
                    child2[i] = 0.5 * ((y1 + y2) + beta * (y2 - y1))
                    
                    # Ensure bounds
                    low, high = self.bounds[i]
                    child1[i] = np.clip(child1[i], low, high)
                    child2[i] = np.clip(child2[i], low, high)
                else:
                    child1[i] = parent1[i]
                    child2[i] = parent2[i]
            else:
                child1[i] = parent1[i]
                child2[i] = parent2[i]
        
        return child1, child2
    
    def _polynomial_mutation(self, individual: np.ndarray, 
                           eta: float = 20.0) -> np.ndarray:
        """Polynomial mutation"""
        mutated = individual.copy()
        
        for i in range(len(mutated)):
            if np.random.random() < self.mutation_rate:
                low, high = self.bounds[i]
                delta1 = (mutated[i] - low) / (high - low)
                delta2 = (high - mutated[i]) / (high - low)
                
                rand = np.random.random()
                mut_pow = 1.0 / (eta + 1.0)
                
                if rand <= 0.5:
                    xy = 1.0 - delta1
                    val = 2.0 * rand + (1.0 - 2.0 * rand) * (xy ** (eta + 1.0))
                    deltaq = val ** mut_pow - 1.0
                else:
                    xy = 1.0 - delta2
                    val = 2.0 * (1.0 - rand) + 2.0 * (rand - 0.5) * (xy ** (eta + 1.0))
                    deltaq = 1.0 - val ** mut_pow
                
                mutated[i] += deltaq * (high - low)
                mutated[i] = np.clip(mutated[i], low, high)
        
        return mutated
    
    def evolve(self, generations: int) -> dict:
        """Main NSGA-II evolution loop"""
        # Initialize population
        population = self._initialize_population()
        
        for generation in range(generations):
            # Evaluate objectives
            objectives = self._evaluate_objectives(population)
            
            # Non-dominated sorting
            fronts, ranks = self._fast_non_dominated_sort(objectives)
            
            # Calculate crowding distances
            crowding_distances = np.zeros(len(population))
            for front in fronts:
                if len(front) > 0:
                    distances = self._calculate_crowding_distance(objectives, front)
                    for i, individual_idx in enumerate(front):
                        crowding_distances[individual_idx] = distances[i]
            
            # Selection for mating pool
            mating_pool_indices = self._tournament_selection(ranks, crowding_distances, 
                                                           self.population_size)
            mating_pool = population[mating_pool_indices]
            
            # Create offspring through crossover and mutation
            offspring = []
            for i in range(0, self.population_size, 2):
                parent1 = mating_pool[i]
                parent2 = mating_pool[i + 1]
                
                child1, child2 = self._sbx_crossover(parent1, parent2)
                child1 = self._polynomial_mutation(child1)
                child2 = self._polynomial_mutation(child2)
                
                offspring.extend([child1, child2])
            
            offspring = np.array(offspring)
            
            # Combine parent and offspring populations
            combined_population = np.vstack([population, offspring])
            combined_objectives = self._evaluate_objectives(combined_population)
            
            # Environmental selection
            combined_fronts, combined_ranks = self._fast_non_dominated_sort(combined_objectives)
            
            new_population = []
            front_idx = 0
            
            # Add complete fronts
            while (len(new_population) + len(combined_fronts[front_idx]) <= self.population_size):
                for individual_idx in combined_fronts[front_idx]:
                    new_population.append(individual_idx)
                front_idx += 1
                
                if front_idx >= len(combined_fronts):
                    break
            
            # Add partial front if needed
            if len(new_population) < self.population_size and front_idx < len(combined_fronts):
                last_front = combined_fronts[front_idx]
                crowding_distances = self._calculate_crowding_distance(combined_objectives, last_front)
                
                # Sort by crowding distance (descending)
                sorted_indices = sorted(range(len(last_front)), 
                                      key=lambda x: crowding_distances[x], reverse=True)
                
                remaining_slots = self.population_size - len(new_population)
                for i in range(remaining_slots):
                    new_population.append(last_front[sorted_indices[i]])
            
            # Update population
            population = combined_population[new_population]
        
        # Final evaluation and return Pareto front
        final_objectives = self._evaluate_objectives(population)
        fronts, _ = self._fast_non_dominated_sort(final_objectives)
        
        pareto_front_indices = fronts[0]
        pareto_front_solutions = population[pareto_front_indices]
        pareto_front_objectives = final_objectives[pareto_front_indices]
        
        return {
            'pareto_front_solutions': pareto_front_solutions,
            'pareto_front_objectives': pareto_front_objectives,
            'final_population': population,
            'final_objectives': final_objectives
        }

# Example: Minimize two objectives (ZDT1 problem)
def objective1(x):
    return x[0]

def objective2(x):
    g = 1 + 9 * np.sum(x[1:]) / (len(x) - 1)
    h = 1 - np.sqrt(x[0] / g)
    return g * h

# Usage
if __name__ == "__main__":
    objectives = [objective1, objective2]
    bounds = [(0, 1)] * 10  # 10-dimensional problem
    
    nsga2 = NSGA2(objectives, 10, bounds, population_size=100)
    result = nsga2.evolve(generations=250)
    
    # Plot Pareto front
    pareto_objectives = result['pareto_front_objectives']
    plt.figure(figsize=(10, 6))
    plt.scatter(pareto_objectives[:, 0], pareto_objectives[:, 1], 
               c='red', alpha=0.7)
    plt.xlabel('Objective 1')
    plt.ylabel('Objective 2')
    plt.title('Pareto Front')
    plt.grid(True, alpha=0.3)
    plt.show()
\end{lstlisting}