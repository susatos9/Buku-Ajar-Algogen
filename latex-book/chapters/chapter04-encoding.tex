\chapter{Encoding pada Algoritma Genetika}

\section{Pendahuluan terhadap Encoding}
Encoding (atau representasi) merumuskan bagaimana solusi calon dinyatakan untuk sebuah algoritma genetik (AG). Misalkan $G$ adalah himpunan diskrit genotipe (ruang representasi) dan $P$ adalah himpunan fenotipe (ruang solusi). Encoding didefinisikan oleh pemetaan
\[\phi: G \to P,\]
yang menetapkan untuk setiap genotipe sebuah fenotipe yang dapat dievaluasi oleh fungsi kecocokan (fitness). Dalam praktiknya $G$ biasanya merupakan ruang kombinatorial hingga atau terhitung (misalnya rangkaian bit, vektor bilangan bulat, permutasi, tree, atau vektor bernilai riil) dan $P$ adalah domain solusi masalah (misalnya vektor riil, jadwal, tur, atau program).

Ada dua aspek encoding yang perlu dibedakan: (i) bahasa representasi yang dipakai untuk membentuk genotipe (bit, integer, bilangan riil, node pada tree, dll.), dan (ii) pemetaan genotipe–fenotipe $\phi$. Pencarian yang dilakukan AG berlangsung pada ruang $G$, sedangkan fungsi kecocokan dan kendala masalah didefinisikan pada $P$; dengan demikian sifat–sifat $\phi$ sangat menentukan bagaimana variasi pada ruang genotipe diterjemahkan menjadi perubahan bermakna pada kualitas solusi.

Encoding yang dipilih dengan baik memperlihatkan struktur yang dapat dimanfaatkan prosedur pencarian, mengurangi kemunculan solusi tak layak, serta mengendalikan redundansi representasi dan epistasis. Encoding yang buruk dapat membuat perbaikan lokal tidak terlihat oleh variasi, menghasilkan lanskap kecocokan patologis, atau mengharuskan prosedur perbaikan yang mahal. Pada bagian selanjutnya kita akan membahas keluarga encoding konkret (biner, Gray, bernilai riil, permutasi, tree) serta implikasi praktisnya terhadap desain representasi dan performa algoritma.

\section{Persyaratan untuk Encoding yang Baik}
Saat merancang encoding dan pemetaan $\phi: G\to P$, berguna untuk merumuskan kriteria secara tegas. Properti-properti berikut menangkap kebutuhan representasional inti dan trade-off; mereka membantu memilih atau menyusun encoding untuk suatu masalah tertentu.

\subsection{Kelengkapan}
Kelengkapan mensyaratkan agar encoding mampu menyatakan setiap fenotipe layak yang relevan: secara formal citra $\phi$ harus mencakup daerah layak $F\subseteq P$, yakni $\phi(G) \supseteq F$. Jika kelengkapan gagal maka beberapa solusi valid tidak dapat dijangkau oleh AG, yang memperkenalkan bias representasional dan dapat mencegah algoritma menemukan solusi optimal di luar $\phi(G)$.

Dalam praktiknya kelengkapan diseimbangkan dengan kepadatan representasi: encoding yang sepenuhnya lengkap mungkin besar atau tidak efisien, sedangkan encoding terbatas dapat menyederhanakan pencarian jika mengecualikan bagian–bagian $P$ yang tidak menarik. Perancang harus menyatakan secara eksplisit subset $P$ mana yang harus dapat dicapai dan memastikan $\phi(G)$ memuatnya.

\subsection{Kebenaran (Soundness)}
Kebenaran atau validitas menyatakan bahwa setiap genotipe harus dipetakan ke fenotipe yang terdefinisi dengan baik dan memenuhi kendala: $\forall g\in G,\ \phi(g) \in P_{valid}$. Encoding yang benar menghindari atau meminimalkan produksi solusi tak layak sehingga evaluasi kecocokan bermakna tanpa perbaikan mahal. Jika kebenaran ketat tidak mungkin, perancang boleh mengizinkan genotipe tak layak tetapi harus menyediakan dekoding dan strategi perbaikan yang efisien dan terdokumentasi sehingga pencarian tetap dapat berlangsung.

Kebenaran dan kelengkapan bersifat ortogonal: sebuah encoding bisa benar tetapi tidak lengkap (setiap genotipe valid, tetapi tidak semua fenotipe dapat direpresentasikan), atau lengkap tetapi tidak benar (semua fenotipe representable tetapi banyak genotipe tidak valid), tergantung pada $G$ dan $\phi$.

\subsection{Non-redundansi}
Non-redundansi berarti mengurangi (atau menghilangkan) banyak genotipe berbeda yang dipetakan pada fenotipe yang sama. Secara formal, diinginkan agar $\phi$ bersifat injektif pada himpunan genotipe yang relevan. Redundansi (pemetaan many-to-one) meningkatkan volume pencarian efektif dan dapat mem-bias sampling: beberapa fenotipe mungkin over-represented di $G$, sehingga lebih sering terjadi sampling meskipun tidak superior.

Namun, redundansi kadang sengaja diperkenalkan demi robustitas (misalnya jaringan netral yang memungkinkan drift netral) atau untuk menyederhanakan representasi. Jika redundansi ada, kuantifikasilah derajatnya dan pertimbangkan interaksinya dengan dinamika pencarian dan operator variasi.

\subsection{Lokalitas}
Lokalitas merumuskan intuisi bahwa perubahan genotipe kecil seharusnya menghasilkan perubahan fenotipe kecil. Misalkan $d_G$ dan $d_P$ adalah ukuran jarak pada $G$ dan $P$ masing-masing (mis. jarak Hamming pada bit-string, jarak Euclidean pada vektor riil). Lokalitas tinggi berarti
\[d_G(g_1,g_2)\ \text{kecil} \Rightarrow d_P(\phi(g_1),\phi(g_2))\ \text{juga kecil}.\]

Lokalitas tidak selalu bisa dicapai bersamaan dengan properti lain yang diinginkan; misalnya encoding injektif dan padat dengan lokalitas sempurna mungkin tidak ada untuk beberapa domain kombinatorial. Perancang harus memprioritaskan properti yang paling penting untuk masalah dan prosedur yang akan dipakai.

\subsection{Persyaratan Praktis Tambahan}
Selain empat properti formal di atas, encoding yang berguna juga harus memenuhi beberapa kendala pragmatis:
\begin{itemize}
	\item \textbf{Operator Closure:} Prosedur variasi sedapat mungkin menghasilkan genotipe di kawasan $G$ yang didekode menjadi fenotipe layak atau mudah diperbaiki.
	\item \textbf{Efisiensi Komputasi:} Dekoding $\phi$ dan prosedur perbaikan harus murah secara komputasi relatif terhadap evaluasi kecocokan.
	\item \textbf{Skalabilitas:} Encoding harus skala secara wajar dengan ukuran masalah; panjang representasi tidak boleh tumbuh supra-linear tanpa alasan.
	\item \textbf{Interpretabilitas dan Pengetahuan Awal:} Bila tersedia, masukkan struktur spesifik domain (simetri, invarian, kendala) untuk menyederhanakan pencarian dan mengurangi derajat kebebasan yang tidak perlu.
\end{itemize}

Merancang encoding adalah soal memenuhi persyaratan formal, kompatibilitas prosedur, dan validasi empiris. Pada bagian berikut akan dibahas keluarga encoding umum dan trade-off praktis yang harus dipertimbangkan.

\section{Encoding Biner}

Encoding biner merepresentasikan genotipe sebagai vektor berdimensi tetap atas alfabet biner: $G=\{0,1\}^l$. Genotipe $g=(b_{l-1},\dots,b_0)$ sering diinterpretasikan sebagai bilangan unsigned
\[\mathrm{bin}(g)=\sum_{i=0}^{l-1} b_i 2^i,\]
yang kemudian dipetakan ke fenotipe melalui dekoding afine bila fenotipe berskala numerik. Untuk variabel bernilai riil $x\in[x_{\min},x_{\max}]$ dekoding yang umum adalah
\begin{equation}
x = x_{\min} + \frac{\mathrm{bin}(g)}{2^l - 1} (x_{\max} - x_{\min}).
\end{equation}
Rumus ini menjelaskan resolusi representasi: langkah kuantisasi adalah
\[\Delta = \frac{x_{\max}-x_{\min}}{2^l-1},\]
sehingga memilih $l$ mempertukarkan presisi dengan dimensionalitas pencarian dan perilaku prosedur variasi.

Encoding biner menarik karena ringkas dan mudah dimanipulasi dengan operasi bitwise. Schema theory dan banyak hasil teoretis awal dikembangkan untuk representasi biner, yang membantu penalaran teoretis tentang konvergensi dan propagasi building-block~\cite{holland1975adaptation,goldberg1989genetic}.

Rekomendasi praktis untuk encoding biner:
\begin{itemize}
	\item Pilih panjang $l$ dari resolusi yang diinginkan $\Delta$ dan rentang $[x_{\min},x_{\max}]$ menggunakan aturan $2^l-1 \ge (x_{\max}-x_{\min})/\Delta$.
	\item Jika kedekatan nilai penting, pertimbangkan Gray coding untuk variabel integer dan konversi ke biner hanya untuk prosedur yang memang bekerja pada bitstring.
	\item Gunakan prosedur yang menghormati batas gen saat menggabungkan beberapa variabel.
\end{itemize}

\section{Ikhtisar Jenis Encoding}

Encoding dapat dikelompokkan menurut struktur $G$ dan domain fenotipe yang dimaksud $P$. Di bawah ini kami merangkum keluarga utama dan kasus penggunaan kanoniknya, disertai panduan praktis dan jebakan umum.

\subsection*{Taksonomi dan pemetaan ke kelas masalah}
\begin{itemize}
	\item \textbf{Biner (bit-string):} $G=\{0,1\}^l$. Baik untuk pilihan kombinatorial dan bila analisis schema diinginkan. Gunakan Gray code atau penyusunan bit spesifik masalah untuk meningkatkan lokalitas pada fenotipe numerik.
	\item \textbf{Permutasi:} Merepresentasikan pengurutan (TSP, penjadwalan). Memerlukan prosedur variasi khusus yang mempertahankan validitas permutasi.
	\item \textbf{Pohon dan graf:} Struktur berukuran variabel untuk pemrograman genetik, evolusi ekspresi, atau topologi rangkaian. Gunakan pertukaran subtree dan kontrol pertumbuhan untuk menghindari bloat.
	\item \textbf{Indirek / perkembangan (developmental):} Genotipe menetapkan aturan konstruksi atau tata bahasa yang menghasilkan fenotipe; berguna bila genotipe ringkas harus menghasilkan fenotipe terstruktur (mis. arsitektur neural, L-systems).
\end{itemize}

\subsection*{Memilih encoding}
Pilih encoding dengan mencocokkan struktur kombinatorial masalah, himpunan kendala, dan toolkit prosedur yang diinginkan. Pertanyaan kunci:
\begin{itemize}
	\item Apakah masalah membutuhkan pengurutan, multiset, atau parameter bernilai riil? Pilih permutasi, integer/multiset, atau encoding riil secara berturut-turut.
	\item Apakah kendala kelayakan bersifat keras (harus dipenuhi) atau lunak (pelanggaran diberi penalti)? Untuk kendala keras, utamakan encoding benar atau decoder konstruktif; untuk kendala lunak penalti mungkin dapat diterima.
	\item Apakah prosedur akan kustom atau standar? Gunakan encoding yang menyederhanakan implementasi prosedur kecuali struktur domain mengharuskan sebaliknya.
\end{itemize}

\subsection*{Kompatibilitas operator dan validasi empiris}
Sebuah encoding berguna hanya jika dipasangkan dengan prosedur yang mempertahankan struktur yang berguna. Setelah memilih encoding, rancang atau pilih prosedur variasi yang menjaga kelayakan, membatasi epistasis destruktif, dan menghormati batas gen yang bermakna. Akhirnya, validasi pilihan encoding secara empiris: bandingkan performa pada benchmark kecil (berbagai encoding, set prosedur, dan laju variasi) dan pilih kombinasi yang menunjukkan kemajuan robust pada instance representatif.

Bagian berikut memberikan contoh representasional konkret dan referensi untuk keluarga encoding utama yang dibahas di sini.

\section{Encoding Bernilai Riil}

Encoding bernilai riil merepresentasikan individu sebagai vektor di $\mathbb{R}^n$, yaitu $\mathbf{x}=(x_1,\dots,x_n)$ dengan setiap koordinat mengambil nilai pada domain kontinu. Representasi langsung ini merupakan pilihan alami untuk masalah optimisasi kontinu dan tugas penyetelan parameter dimana fenotipe secara inheren numerik. Dengan beroperasi dalam ruang kontinu, encoding riil menghindari artefak kuantisasi dari encoding biner berdimensi tetap dan memungkinkan operator variasi mengekspresikan penyesuaian yang sangat kecil pada solusi kandidat (tergantung batas presisi floating-point)~\cite{back1996evolutionary,michalewicz1996genetic}.





\section{Encoding Integer}

Encoding integer merepresentasikan solusi yang variabelnya mengambil nilai bilangan bulat diskrit. Secara formal individu adalah vektor $\mathbf{x}=(x_1,\dots,x_n)$ dengan setiap koordinat $x_i\in\mathbb{Z}$ dan, dalam praktik, dibatasi ke domain hingga $[a_i,b_i]\cap\mathbb{Z}$. Representasi ini sesuai untuk masalah alokasi, jumlah, dan banyak substruktur kombinatorial (mis. kuantitas pada knapsack, alokasi sumber daya, dan parameter kontrol yang didiskretisasi). Sifat diskrit variabel mengubah karakter pencarian: lingkungan (neighbourhood) didefinisikan oleh langkah-integer, dan lanskap pencarian bersifat tidak kontinu dan sering non-konveks.


Encoding integer memiliki trade-off dibandingkan representasi riil. Karena domain diskrit, banyak asumsi analitik (mis. gradien mulus atau konveksitas kontinu) tidak berlaku, dan mekanisme adaptasi ukuran langkah kontinu perlu disesuaikan ke skala langkah diskrit. Di sisi lain, representasi integer dapat menyandikan kelayakan secara langsung, menghindari prosedur perbaikan mahal: mis. merepresentasikan kuantitas dengan integritas memastikan kendala alami.

Dari perspektif desain algoritma dan implementasi, beberapa rekomendasi pragmatis meningkatkan robustitas. Pertama, manfaatkan struktur masalah: bila variabel memiliki rentang integer kecil gunakan gerakan neighbourhood enumeratif dan hibrida pencarian lokal langkah-kecil; bila rentang besar, pilih operator yang mengeksplor luas (random-reset, proposal langkah besar) dikombinasikan dengan pengurangan adaptif magnitudo langkah. Kedua, tegakkan batas dan invarian dalam decoder atau melalui proyeksi setelah variasi daripada mengandalkan pemangkasan implisit; operator sadar-kendala eksplisit biasanya lebih jelas dan kurang rawan kesalahan. Ketiga, saat mencampur variabel integer dan kontinu gunakan operator campuran-integer atau jadwal terpisah sehingga setiap tipe variabel menerima variasi dengan skala yang sesuai.


\section{Encoding Permutasi}

Encoding permutasi merepresentasikan solusi calon sebagai permutasi dari himpunan hingga elemen, yaitu ruang genotipe adalah himpunan bijeksi pada $\{1,\dots,n\}$. Pemetaan genotipe–fenotipe $\phi$ biasanya merupakan peta identitas: sebuah permutasi langsung menentukan pengurutan yang diinterpretasikan oleh evaluator spesifik masalah (mis. tur pada travelling salesman problem, urutan job pada penjadwalan satu mesin, atau daftar tugas terurut untuk lini aliran). Karena permutasi secara inheren menegakkan kendala pengurutan, encoding permutasi bersifat benar (sound) untuk masalah pengurutan dan menghindari banyak perbaikan kelayakan yang diperlukan oleh encoding naif.

Jarak dan lokalitas di ruang permutasi sangat berbeda dari ruang vektor. Jarak Hamming atau metrik posisi sederhana tidak menangkap struktur neighbourhood yang bermakna untuk masalah berbasis urutan. Jarak seperti Kendall tau (jumlah ketidaksepakatan berpasangan), inversi, atau metrik berbasis edge (jumlah perbedaan hubungan kedekatan) lebih mencerminkan perubahan kecil yang dapat diinterpretasikan dan mempertahankan struktur masalah. Desain operator harus dipandu oleh aspek permutasi mana yang merupakan building-block berguna untuk masalah — blok berbasis posisi, blok adjacency/edge, atau relasi precedence — karena operator berbeda melestarikan struktur yang berbeda.

Operator variasi untuk encoding permutasi harus menjaga kelayakan (menghasilkan permutasi valid) dan idealnya menghormati notion lokalitas yang dipilih. Mutasi tipikal meliputi swap, insert (mengambil satu elemen dan memasukkannya ke posisi lain), dan inversi/ reversal subsekuens; ini memiliki interpretasi jelas sebagai reorder lokal kecil. 

Alternatifnya adalah menggunakan encoding tidak langsung dan decoder konstruktif bila kendala atau heuristik konstruktif penting. Encoding prioritas atau random-key memetakan kunci bernilai riil ke permutasi melalui decoder sorting stabil; decoder konstruktif membangun jadwal atau tur layak secara greedy dari genotipe yang menyandikan preferensi. Encoding tidak langsung dapat sangat mengurangi kompleksitas desain dengan memisahkan pencarian genetik dari penegakan kelayakan dan dapat memasukkan heuristik domain ke dalam decoder, tetapi mereka memindahkan beban desain ke decoder dan dapat mengaburkan sifat lokalitas operator genetik.

Rekomendasi praktis: inisialisasi populasi menggunakan campuran permutasi acak dan heuristik spesifik masalah untuk menabur struktur berguna; ukur keberagaman dengan metrik yang menyadari permutasi (Kendall tau atau overlap edge) daripada jarak Hamming; utamakan operator yang melestarikan notion building-block relevan; dan gabungkan pencarian global berbasis permutasi dengan optimisasi lokal (mis. 2-opt atau 3-opt untuk TSP, atau pencarian neighbourhood khusus untuk penjadwalan) untuk memanfaatkan perbaikan halus. Saat simetri ada, gunakan kanonisasi atau evaluasi yang menyadari ekuivalensi untuk menghindari bias. Akhirnya, validasi pilihan secara empiris pada instance representatif karena efektivitas operator sangat bergantung pada masalah di ruang permutasi.

\section{Tree Encoding}

Tree Encoding merepresentasikan genotipe sebagai tree berakar berlabel dimana node membawa simbol yang diambil dari satu atau lebih alfabet (mis. simbol fungsi/operator untuk node internal dan simbol terminal untuk daun). Fenotipe diperoleh dengan menginterpretasikan tree sesuai semantik masalah: dalam pemrograman genetik tree menyatakan ekspresi atau program, dalam optimisasi sintaksis ia merepresentasikan tree parse, dan dalam desain hierarkis ia merepresentasikan komposisi komponen. Secara formal ruang genotipe adalah himpunan tree terurut hingga atas alfabet berperingkat, dan decoder $\phi$ adalah fungsi evaluasi atau instansiasi yang memetakan tree ke objek spesifik masalah di $P$.

Tree Encoding memperkenalkan pilihan representasional yang sangat mempengaruhi perilaku operator dan dinamika pencarian. Perancang harus menentukan alfabet node (bertipe atau tidak), kendala aritas (tetap atau variabel), dan linearisation untuk penyimpanan (struktur pointer, string berpagar, notasi prefix/postfix, atau daftar anak eksplisit). Pohon bertipe (strongly-typed) menegakkan kendala sintaksis pada tingkat representasi, mencegah banyak keturunan tidak valid dan mengurangi kebutuhan perbaikan; tree tidak bertipe lebih fleksibel tetapi sering memerlukan pemeriksaan kelayakan tambahan atau decoder. Representasi memengaruhi lokalitas: penggantian subtree kecil dapat menimbulkan perubahan semantik besar ketika semantik node bersifat non-linier atau konteks-sensitif.


Encoding indirek dan berbasis tata bahasa sangat berguna bila fenotipe harus memenuhi kendala sintaksis atau semantik yang kaya. Dalam grammatical evolution dan grammar-guided GP, genotipe biasanya menyandikan derivasi atau urutan pilihan produksi, dan decoder deterministik memetakannya ke tree yang dijamin valid secara sintaksis. Encoding indirek ini dapat menghasilkan genotipe ringkas dan memungkinkan memasukkan pengetahuan domain, tetapi dapat mengaburkan sifat lokalitas operator dan membutuhkan desain decoder yang hati-hati untuk menghindari sampling fenotipe yang bias.

Rekomendasi praktis: tegakkan kelayakan sejak dini menggunakan pengetipan atau kendala tata bahasa bila domain memerlukan kebenaran sintaksis; gabungkan pencarian tree global dengan lintasan penyederhanaan lokal (constant folding, reduksi aljabar) untuk meningkatkan efisiensi evaluasi; gunakan strategi inisialisasi campuran (ramped half-and-half, grow/full) untuk menabur variasi ukuran dan bentuk tree; dan terapkan kontrol kompleksitas eksplisit (tekanan parsimoni, batas kedalaman, atau bias operator adaptif) untuk mengelola bloat. Akhirnya, validasi operator secara empiris pada instance representatif dan pantau ukuran tree, kedalaman, dan biaya evaluasi selama eksperimen untuk mendeteksi bloat atau perilaku patologis.



