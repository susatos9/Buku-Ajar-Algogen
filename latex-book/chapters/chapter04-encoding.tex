\chapter{Encoding pada Algoritma Genetika}

\section{Pendahuluan terhadap Encoding}
Encoding (atau representasi) merumuskan bagaimana solusi calon dinyatakan untuk sebuah algoritma genetik (AG). Misalkan $G$ adalah himpunan diskrit genotipe (ruang representasi) dan $P$ adalah himpunan fenotipe (ruang solusi). Encoding didefinisikan oleh pemetaan
\[\phi: G \to P,\]
yang menetapkan untuk setiap genotipe sebuah fenotipe yang dapat dievaluasi oleh fungsi kecocokan (fitness). Dalam praktiknya $G$ biasanya merupakan ruang kombinatorial hingga atau terhitung (misalnya rangkaian bit, vektor bilangan bulat, permutasi, tree, atau vektor bernilai riil) dan $P$ adalah domain solusi masalah (misalnya vektor riil, jadwal, tur, atau program).

Ada dua aspek encoding yang perlu dibedakan: (i) bahasa representasi yang dipakai untuk membentuk genotipe (bit, integer, bilangan riil, node pada tree, dll.), dan (ii) pemetaan genotipe–fenotipe $\phi$. Pencarian yang dilakukan AG berlangsung pada ruang $G$, sedangkan fungsi kecocokan dan kendala masalah didefinisikan pada $P$; dengan demikian sifat–sifat $\phi$ sangat menentukan bagaimana variasi pada ruang genotipe diterjemahkan menjadi perubahan bermakna pada kualitas solusi.

Encoding yang dipilih dengan baik memperlihatkan struktur yang dapat dimanfaatkan prosedur pencarian, mengurangi kemunculan solusi tak layak, serta mengendalikan redundansi representasi dan epistasis. Encoding yang buruk dapat membuat perbaikan lokal tidak terlihat oleh variasi, menghasilkan lanskap kecocokan patologis, atau mengharuskan prosedur perbaikan yang mahal. Pada bagian selanjutnya kita akan membahas keluarga encoding konkret (biner, Gray, bernilai riil, permutasi, tree) serta implikasi praktisnya terhadap desain representasi dan performa algoritma.

\section{Persyaratan untuk Encoding yang Baik}
Saat merancang encoding dan pemetaan $\phi: G\to P$, berguna untuk merumuskan kriteria secara tegas. Properti-properti berikut menangkap kebutuhan representasional inti dan trade-off; mereka membantu memilih atau menyusun encoding untuk suatu masalah tertentu.

\subsection{Kelengkapan}
Kelengkapan mensyaratkan agar encoding mampu menyatakan setiap fenotipe layak yang relevan: secara formal citra $\phi$ harus mencakup daerah layak $F\subseteq P$, yakni $\phi(G) \supseteq F$. Jika kelengkapan gagal maka beberapa solusi valid tidak dapat dijangkau oleh AG, yang memperkenalkan bias representasional dan dapat mencegah algoritma menemukan solusi optimal di luar $\phi(G)$.

Dalam praktiknya kelengkapan diseimbangkan dengan kepadatan representasi: encoding yang sepenuhnya lengkap mungkin besar atau tidak efisien, sedangkan encoding terbatas dapat menyederhanakan pencarian jika mengecualikan bagian–bagian $P$ yang tidak menarik. Perancang harus menyatakan secara eksplisit subset $P$ mana yang harus dapat dicapai dan memastikan $\phi(G)$ memuatnya.

\subsection{Kebenaran (Soundness)}
Kebenaran atau validitas menyatakan bahwa setiap genotipe harus dipetakan ke fenotipe yang terdefinisi dengan baik dan memenuhi kendala: $\forall g\in G,\ \phi(g) \in P_{valid}$. Encoding yang benar menghindari atau meminimalkan produksi solusi tak layak sehingga evaluasi kecocokan bermakna tanpa perbaikan mahal. Jika kebenaran ketat tidak mungkin, perancang boleh mengizinkan genotipe tak layak tetapi harus menyediakan dekoding dan strategi perbaikan yang efisien dan terdokumentasi sehingga pencarian tetap dapat berlangsung.

Kebenaran dan kelengkapan bersifat ortogonal: sebuah encoding bisa benar tetapi tidak lengkap (setiap genotipe valid, tetapi tidak semua fenotipe dapat direpresentasikan), atau lengkap tetapi tidak benar (semua fenotipe representable tetapi banyak genotipe tidak valid), tergantung pada $G$ dan $\phi$.

\subsection{Non-redundansi}
Non-redundansi berarti mengurangi (atau menghilangkan) banyak genotipe berbeda yang dipetakan pada fenotipe yang sama. Secara formal, diinginkan agar $\phi$ bersifat injektif pada himpunan genotipe yang relevan. Redundansi (pemetaan many-to-one) meningkatkan volume pencarian efektif dan dapat mem-bias sampling: beberapa fenotipe mungkin over-represented di $G$, sehingga lebih sering terjadi sampling meskipun tidak superior.

Namun, redundansi kadang sengaja diperkenalkan demi robustitas (misalnya jaringan netral yang memungkinkan drift netral) atau untuk menyederhanakan representasi. Jika redundansi ada, kuantifikasilah derajatnya dan pertimbangkan interaksinya dengan dinamika pencarian dan operator variasi.

\subsection{Lokalitas}
Lokalitas merumuskan intuisi bahwa perubahan genotipe kecil seharusnya menghasilkan perubahan fenotipe kecil. Misalkan $d_G$ dan $d_P$ adalah ukuran jarak pada $G$ dan $P$ masing-masing (mis. jarak Hamming pada bit-string, jarak Euclidean pada vektor riil). Lokalitas tinggi berarti
\[d_G(g_1,g_2)\ \text{kecil} \Rightarrow d_P(\phi(g_1),\phi(g_2))\ \text{juga kecil}.\]
Lokalitas penting karena prosedur variasi umum membuat perubahan kecil di $G$; bila perubahan ini tidak berkorelasi dengan perubahan kecil di $P$, pencarian menjadi pada dasarnya acak dan rekombinasi building-block gagal. Pilihan encoding seperti Gray coding untuk bilangan bulat atau representasi bernilai riil bertujuan meningkatkan lokalitas.

Lokalitas tidak selalu bisa dicapai bersamaan dengan properti lain yang diinginkan; misalnya encoding injektif dan padat dengan lokalitas sempurna mungkin tidak ada untuk beberapa domain kombinatorial. Perancang harus memprioritaskan properti yang paling penting untuk masalah dan prosedur yang akan dipakai.

\subsection{Persyaratan Praktis Tambahan}
Selain empat properti formal di atas, encoding yang berguna juga harus memenuhi beberapa kendala pragmatis:
\begin{itemize}
	\item \textbf{Operator Closure:} Prosedur variasi sedapat mungkin menghasilkan genotipe di kawasan $G$ yang didekode menjadi fenotipe layak atau mudah diperbaiki.
	\item \textbf{Efisiensi Komputasi:} Dekoding $\phi$ dan prosedur perbaikan harus murah secara komputasi relatif terhadap evaluasi kecocokan.
	\item \textbf{Skalabilitas:} Encoding harus skala secara wajar dengan ukuran masalah; panjang representasi tidak boleh tumbuh supra-linear tanpa alasan.
	\item \textbf{Epistasis Rendah:} Representasi sebaiknya meminimalkan interaksi destruktif antar gen (epistasis) sehingga building-block yang menguntungkan dapat direkombinasikan secara andal.
	\item \textbf{Interpretabilitas dan Pengetahuan Awal:} Bila tersedia, masukkan struktur spesifik domain (simetri, invarian, kendala) untuk menyederhanakan pencarian dan mengurangi derajat kebebasan yang tidak perlu.
\end{itemize}

Merancang encoding adalah soal memenuhi persyaratan formal, kompatibilitas prosedur, dan validasi empiris. Pada bagian berikut akan dibahas keluarga encoding umum dan trade-off praktis yang harus dipertimbangkan.

\section{Encoding Biner}

Encoding biner merepresentasikan genotipe sebagai vektor berdimensi tetap atas alfabet biner: $G=\{0,1\}^l$. Genotipe $g=(b_{l-1},\dots,b_0)$ sering diinterpretasikan sebagai bilangan unsigned
\[\mathrm{bin}(g)=\sum_{i=0}^{l-1} b_i 2^i,\]
yang kemudian dipetakan ke fenotipe melalui dekoding afine bila fenotipe berskala numerik. Untuk variabel bernilai riil $x\in[x_{\min},x_{\max}]$ dekoding yang umum adalah
\begin{equation}
x = x_{\min} + \frac{\mathrm{bin}(g)}{2^l - 1} (x_{\max} - x_{\min}).
\end{equation}
Rumus ini menjelaskan resolusi representasi: langkah kuantisasi adalah
\[\Delta = \frac{x_{\max}-x_{\min}}{2^l-1},\]
sehingga memilih $l$ mempertukarkan presisi dengan dimensionalitas pencarian dan perilaku prosedur variasi.

Encoding biner menarik karena ringkas dan mudah dimanipulasi dengan operasi bitwise. Schema theory dan banyak hasil teoretis awal dikembangkan untuk representasi biner, yang membantu penalaran teoretis tentang konvergensi dan propagasi building-block~\cite{holland1975adaptation,goldberg1989genetic}.

Namun, encoding biner juga memperkenalkan masalah khusus yang perlu ditangani:
\begin{itemize}
	\item \textbf{Hamming cliffs dan lokalitas:} Nilai numerik berdekatan dapat berbeda di banyak bit pada encoding posisi biner standar, sehingga merusak lokalitas. Kode Gray adalah obat umum bila menjaga kedekatan penting.
	\item \textbf{Presisi versus panjang:} Presisi tinggi membutuhkan bit-string panjang, yang memperluas ruang pencarian secara eksponensial dan dapat membuat rekombinasi posisional menjadi sangat disruptif.
	\item \textbf{Epistasis:} Posisi bit dapat berinteraksi secara non-linier terhadap kualitas fenotipe; bit yang berkorelasi mengurangi efektivitas rekombinasi sederhana.
\end{itemize}

Rekomendasi praktis untuk encoding biner:
\begin{itemize}
	\item Pilih panjang $l$ dari resolusi yang diinginkan $\Delta$ dan rentang $[x_{\min},x_{\max}]$ menggunakan aturan $2^l-1 \ge (x_{\max}-x_{\min})/\Delta$.
	\item Jika kedekatan nilai penting, pertimbangkan Gray coding untuk variabel integer dan konversi ke biner hanya untuk prosedur yang memang bekerja pada bitstring.
	\item Gunakan prosedur yang menghormati batas gen saat menggabungkan beberapa variabel (mis. sesuaikan titik rekombinasi ke batas variabel bila relevan).
	\item Stemper laju modifikasi per-bit sebagai heuristik awal; kurangi bila menggunakan pencarian lokal atau dinamika seleksi yang kuat.
\end{itemize}

\section{Ikhtisar Jenis Encoding}

Encoding dapat dikelompokkan menurut struktur $G$ dan domain fenotipe yang dimaksud $P$. Di bawah ini kami merangkum keluarga utama dan kasus penggunaan kanoniknya, disertai panduan praktis dan jebakan umum.

\subsection*{Taksonomi dan pemetaan ke kelas masalah}
\begin{itemize}
	\item \textbf{Biner (bit-string):} $G=\{0,1\}^l$. Baik untuk pilihan kombinatorial dan bila analisis schema diinginkan. Gunakan Gray code atau penyusunan bit spesifik masalah untuk meningkatkan lokalitas pada fenotipe numerik.
	\item \textbf{Integer:} Vektor bilangan bulat; alami untuk masalah alokasi dan penghitungan. Gunakan prosedur variasi yang sadar-integer (random-reset, creep) dan metode rekombinasi diskrit.
	\item \textbf{Bernilai riil (real-valued):} Vektor kontinu $\mathbb{R}^n$. Direkomendasikan untuk optimisasi kontinu; mendukung kombinasi aritmetik, rekombinasi BLX-$\alpha$, gangguan stokastik, dan hibrida berbasis gradien.
	\item \textbf{Permutasi:} Merepresentasikan pengurutan (TSP, penjadwalan). Memerlukan prosedur variasi khusus yang mempertahankan validitas permutasi.
	\item \textbf{Pohon dan graf:} Struktur berukuran variabel untuk pemrograman genetik, evolusi ekspresi, atau topologi rangkaian. Gunakan pertukaran subtree dan kontrol pertumbuhan untuk menghindari bloat.
	\item \textbf{Indirek / perkembangan (developmental):} Genotipe menetapkan aturan konstruksi atau tata bahasa yang menghasilkan fenotipe; berguna bila genotipe ringkas harus menghasilkan fenotipe terstruktur (mis. arsitektur neural, L-systems).
\end{itemize}

\subsection*{Memilih encoding}
Pilih encoding dengan mencocokkan struktur kombinatorial masalah, himpunan kendala, dan toolkit prosedur yang diinginkan. Pertanyaan kunci:
\begin{itemize}
	\item Apakah masalah membutuhkan pengurutan, multiset, atau parameter bernilai riil? Pilih permutasi, integer/multiset, atau encoding riil secara berturut-turut.
	\item Apakah kendala kelayakan bersifat keras (harus dipenuhi) atau lunak (pelanggaran diberi penalti)? Untuk kendala keras, utamakan encoding benar atau decoder konstruktif; untuk kendala lunak penalti mungkin dapat diterima.
	\item Apakah lokalitas penting untuk rekombinasi efektif? Jika ya, pilih encoding atau transformasi (mis. Gray) yang meningkatkan korelasi antara perubahan genotipe kecil dan perubahan fenotipe.
	\item Apakah prosedur akan kustom atau standar? Gunakan encoding yang menyederhanakan implementasi prosedur kecuali struktur domain mengharuskan sebaliknya.
\end{itemize}

\subsection*{Kompatibilitas operator dan validasi empiris}
Sebuah encoding berguna hanya jika dipasangkan dengan prosedur yang mempertahankan struktur yang berguna. Setelah memilih encoding, rancang atau pilih prosedur variasi yang menjaga kelayakan, membatasi epistasis destruktif, dan menghormati batas gen yang bermakna. Akhirnya, validasi pilihan encoding secara empiris: bandingkan performa pada benchmark kecil (berbagai encoding, set prosedur, dan laju variasi) dan pilih kombinasi yang menunjukkan kemajuan robust pada instance representatif.

Bagian berikut memberikan contoh representasional konkret dan referensi untuk keluarga encoding utama yang dibahas di sini.

\section{Encoding Bernilai Riil}

Encoding bernilai riil merepresentasikan individu sebagai vektor di $\mathbb{R}^n$, yaitu $\mathbf{x}=(x_1,\dots,x_n)$ dengan setiap koordinat mengambil nilai pada domain kontinu. Representasi langsung ini merupakan pilihan alami untuk masalah optimisasi kontinu dan tugas penyetelan parameter dimana fenotipe secara inheren numerik. Dengan beroperasi dalam ruang kontinu, encoding riil menghindari artefak kuantisasi dari encoding biner berdimensi tetap dan memungkinkan operator variasi mengekspresikan penyesuaian yang sangat kecil pada solusi kandidat (tergantung batas presisi floating-point)~\cite{back1996evolutionary,michalewicz1996genetic}.

Keuntungan praktis utama encoding riil adalah kompatibilitas operator: rekombinasi aritmetik (rata-rata berbobot), rekombinasi interval BLX-$\alpha$, simulated binary crossover (SBX), serta mutasi dengan gangguan Gaussian atau Cauchy bekerja alami pada vektor riil dan dapat dirancang untuk menghormati batas atau struktur yang diketahui. Operator ini menghasilkan keturunan yang berada dalam kerangka cembung (atau perpanjangan terkendali) dari orang tua, yang biasanya memberikan lintasan pencarian lebih mulus dan eksploitasi gradien lokal yang lebih baik pada lanskap kecocokan. Evolution Strategies (ES) dan banyak optimiser kontinu modern memanfaatkan properti ini dengan menggabungkan kontrol langkah adaptif mandiri dengan rekombinasi untuk menavigasi lanskap yang kasar namun dapat diturunkan secara efisien~\cite{back1996evolutionary}.

Namun demikian ada trade-off teoretis dan praktis. Argumen schema klasik untuk representasi biner tidak langsung berlaku untuk encoding kontinu: konsep building-block harus diformulasikan ulang dalam istilah daerah di $\mathbb{R}^n$ dan korelasi yang diinduksi operator antar koordinat. Encoding riil juga menempatkan penekanan lebih pada pilihan algoritmik untuk kontrol ukuran langkah dan penanganan kendala — skala mutasi yang buruk atau rekombinasi tak terbatas dapat menyebabkan kemajuan lambat atau ketidakstabilan numerik. Oleh karena itu praktisi harus menyetel atau mengadaptasi magnitudo mutasi (jadwal tetap, adaptasi mandiri, atau adaptasi matriks kovarians) dan memilih parameter rekombinasi yang cocok dengan kelancaran dan skala masalah.

Dari sisi implementasi, beberapa rekomendasi pragmatis meningkatkan robustitas dan performa. Selalu normalisasi atau skala variabel ke rentang yang sebanding sebelum menerapkan operator generik; ini mencegah koordinat tunggal mendominasi statistik rekombinasi dan menyederhanakan transfer parameter antar masalah. Gunakan operator terbatas atau skema proyeksi bila ada kendala, dan pilih strategi mutasi adaptif (mis. adaptasi ukuran langkah log-normal atau pembaruan kovarians ala CMA) bila lanskap pencarian menunjukkan anisotropi. Bila gradien lokal tersedia atau dapat didekati murah, menggabungkan pembaruan evolusioner dengan penyempurnaan berbasis gradien sering mempercepat konvergensi sambil mempertahankan eksplorasi global.

Seperti pilihan encoding lainnya, representasi riil harus divalidasi secara empiris terhadap alternatif. Untuk banyak masalah kontinu yang mulus dan berdimensi rendah hingga sedang, encoding riil secara substansial mengungguli encoding biner baik dari segi kecepatan konvergensi maupun kualitas solusi akhir; untuk masalah sangat multimodal atau kombinatorial, parameterisasi riil mungkin tidak sesuai. Oleh karena itu disarankan memulai dengan set operator riil sederhana (rekombinasi aritmetik/BLX dan mutasi Gaussian dengan deviasi baku yang disetel), lakukan eksperimen faktorial kecil untuk memilih mekanisme adaptasi, dan gunakan adaptasi lebih canggih (ukuran langkah adaptif, CMA) bila skala masalah atau perilaku pencarian memerlukannya.

\section{Encoding Integer}

Encoding integer merepresentasikan solusi yang variabelnya mengambil nilai bilangan bulat diskrit. Secara formal individu adalah vektor $\mathbf{x}=(x_1,\dots,x_n)$ dengan setiap koordinat $x_i\in\mathbb{Z}$ dan, dalam praktik, dibatasi ke domain hingga $[a_i,b_i]\cap\mathbb{Z}$. Representasi ini sesuai untuk masalah alokasi, jumlah, dan banyak substruktur kombinatorial (mis. kuantitas pada knapsack, alokasi sumber daya, dan parameter kontrol yang didiskretisasi). Sifat diskrit variabel mengubah karakter pencarian: lingkungan (neighbourhood) didefinisikan oleh langkah-integer, dan lanskap pencarian bersifat tidak kontinu dan sering non-konveks.

Operator untuk encoding integer harus menghormati integritas dan batas domain atau kendala kelayakan. Strategi mutasi umum meliputi random-reset (mengganti koordinat dengan integer uniform di domainnya) dan "creep" (menaikkan atau menurunkan dengan langkah kecil yang diambil dari distribusi berekor pendek). Rekombinasi dapat dilakukan langsung di domain integer (mis. discrete uniform crossover atau seleksi per-koordinat), atau dengan mengangkat sementara nilai ke surrogate kontinu (rekombinasi aritmetik diikuti pembulatan) bila operator yang memanfaatkan rata-rata diinginkan. Saat menggunakan rekombinasi kontinu surrogate, pembulatan stokastik atau pembulatan koreksi bias membantu mengurangi artefak pembulatan sistematis.

Encoding integer memiliki trade-off dibandingkan representasi riil. Karena domain diskrit, banyak asumsi analitik (mis. gradien mulus atau konveksitas kontinu) tidak berlaku, dan mekanisme adaptasi ukuran langkah kontinu perlu disesuaikan ke skala langkah diskrit. Di sisi lain, representasi integer dapat menyandikan kelayakan secara langsung, menghindari prosedur perbaikan mahal: mis. merepresentasikan kuantitas dengan integritas memastikan kendala alami, dan operator rekombinasi/mutasi diskrit khusus dapat dirancang untuk mempertahankan kelayakan atau hampir-kelayakan secara konstruktif.

Dari perspektif desain algoritma dan implementasi, beberapa rekomendasi pragmatis meningkatkan robustitas. Pertama, manfaatkan struktur masalah: bila variabel memiliki rentang integer kecil gunakan gerakan neighbourhood enumeratif dan hibrida pencarian lokal langkah-kecil; bila rentang besar, pilih operator yang mengeksplor luas (random-reset, proposal langkah besar) dikombinasikan dengan pengurangan adaptif magnitudo langkah. Kedua, tegakkan batas dan invarian dalam decoder atau melalui proyeksi setelah variasi daripada mengandalkan pemangkasan implisit; operator sadar-kendala eksplisit biasanya lebih jelas dan kurang rawan kesalahan. Ketiga, saat mencampur variabel integer dan kontinu gunakan operator campuran-integer atau jadwal terpisah sehingga setiap tipe variabel menerima variasi dengan skala yang sesuai.

Terakhir, validasi pilihan encoding secara empiris. Bandingkan encoding integer langsung dengan alternatif (integer yang dikodekan biner, surrogate bernilai riil dengan pembulatan) pada instance representatif kecil untuk mengukur kecepatan konvergensi, robustitas, dan biaya penanganan kendala. Pada banyak tugas alokasi atau penjadwalan, representasi integer yang dipilih dengan baik ditambah operator diskrit khusus mengungguli surrogate kontinu umum; namun untuk masalah yang membutuhkan perilaku pencarian halus, strategi kontinuu surrogate dengan pembulatan dan adaptasi ukuran langkah yang cermat dapat bersaing. Gunakan hasil empiris ini untuk memilih skala mutasi/rekombinasi dan memutuskan apakah akan menggabungkan loop evolusioner dengan pencarian lokal deterministik pada neighbourhood integer.

\section{Encoding Permutasi}

Encoding permutasi merepresentasikan solusi calon sebagai permutasi dari himpunan hingga elemen, yaitu ruang genotipe adalah himpunan bijeksi pada $\{1,\dots,n\}$. Pemetaan genotipe–fenotipe $\phi$ biasanya merupakan peta identitas: sebuah permutasi langsung menentukan pengurutan yang diinterpretasikan oleh evaluator spesifik masalah (mis. tur pada travelling salesman problem, urutan job pada penjadwalan satu mesin, atau daftar tugas terurut untuk lini aliran). Karena permutasi secara inheren menegakkan kendala pengurutan, encoding permutasi bersifat benar (sound) untuk masalah pengurutan dan menghindari banyak perbaikan kelayakan yang diperlukan oleh encoding naif.

Walau secara formal permutasi bersifat satu-ke-satu terhadap pengurutan, representasi praktis sering memperkenalkan kelas ekuivalen dan redundansi yang harus dikenali. Tur melingkar (seperti pada TSP simetris) memiliki simetri rotasi: pergeseran siklik permutasi mewakili tur yang sama dan refleksi juga mungkin ekuivalen. Simetri semacam ini tidak mengubah validitas tetapi memengaruhi sampling dan probabilitas seleksi; perancang harus memilih representatif kanonik (memasang kota pertama) atau menggunakan operator dan perbandingan fitness yang menyadari kelas ekuivalen untuk menghindari bias representasional.

Jarak dan lokalitas di ruang permutasi sangat berbeda dari ruang vektor. Jarak Hamming atau metrik posisi sederhana tidak menangkap struktur neighbourhood yang bermakna untuk masalah berbasis urutan. Jarak seperti Kendall tau (jumlah ketidaksepakatan berpasangan), inversi, atau metrik berbasis edge (jumlah perbedaan hubungan kedekatan) lebih mencerminkan perubahan kecil yang dapat diinterpretasikan dan mempertahankan struktur masalah. Desain operator harus dipandu oleh aspek permutasi mana yang merupakan building-block berguna untuk masalah — blok berbasis posisi, blok adjacency/edge, atau relasi precedence — karena operator berbeda melestarikan struktur yang berbeda.

Operator variasi untuk encoding permutasi harus menjaga kelayakan (menghasilkan permutasi valid) dan idealnya menghormati notion lokalitas yang dipilih. Mutasi tipikal meliputi swap, insert (mengambil satu elemen dan memasukkannya ke posisi lain), dan inversi/ reversal subsekuens; ini memiliki interpretasi jelas sebagai reorder lokal kecil. Operator rekombinasi dirancang untuk menggabungkan urutan orang tua sambil mempertahankan validitas permutasi: contoh termasuk partially mapped crossover (PMX), order crossover (OX), cycle crossover (CX), dan edge recombination. Masing-masing menekankan struktur yang dilestarikan berbeda (posisi, urutan, atau adjacency) dan pilihan harus sesuai dengan building-block spesifik masalah (mis. edge-based recombiners alami untuk TSP di mana edge lebih penting daripada posisi absolut).

Alternatifnya adalah menggunakan encoding tidak langsung dan decoder konstruktif bila kendala atau heuristik konstruktif penting. Encoding prioritas atau random-key memetakan kunci bernilai riil ke permutasi melalui decoder sorting stabil; decoder konstruktif membangun jadwal atau tur layak secara greedy dari genotipe yang menyandikan preferensi. Encoding tidak langsung dapat sangat mengurangi kompleksitas desain dengan memisahkan pencarian genetik dari penegakan kelayakan dan dapat memasukkan heuristik domain ke dalam decoder, tetapi mereka memindahkan beban desain ke decoder dan dapat mengaburkan sifat lokalitas operator genetik.

Rekomendasi praktis: inisialisasi populasi menggunakan campuran permutasi acak dan heuristik spesifik masalah untuk menabur struktur berguna; ukur keberagaman dengan metrik yang menyadari permutasi (Kendall tau atau overlap edge) daripada jarak Hamming; utamakan operator yang melestarikan notion building-block relevan; dan gabungkan pencarian global berbasis permutasi dengan optimisasi lokal (mis. 2-opt atau 3-opt untuk TSP, atau pencarian neighbourhood khusus untuk penjadwalan) untuk memanfaatkan perbaikan halus. Saat simetri ada, gunakan kanonisasi atau evaluasi yang menyadari ekuivalensi untuk menghindari bias. Akhirnya, validasi pilihan secara empiris pada instance representatif karena efektivitas operator sangat bergantung pada masalah di ruang permutasi.

\section{Tree Encoding}

Tree Encoding merepresentasikan genotipe sebagai tree berakar berlabel dimana node membawa simbol yang diambil dari satu atau lebih alfabet (mis. simbol fungsi/operator untuk node internal dan simbol terminal untuk daun). Fenotipe diperoleh dengan menginterpretasikan tree sesuai semantik masalah: dalam pemrograman genetik tree menyatakan ekspresi atau program, dalam optimisasi sintaksis ia merepresentasikan tree parse, dan dalam desain hierarkis ia merepresentasikan komposisi komponen. Secara formal ruang genotipe adalah himpunan tree terurut hingga atas alfabet berperingkat, dan decoder $\phi$ adalah fungsi evaluasi atau instansiasi yang memetakan tree ke objek spesifik masalah di $P$.

Tree Encoding memperkenalkan pilihan representasional yang sangat mempengaruhi perilaku operator dan dinamika pencarian. Perancang harus menentukan alfabet node (bertipe atau tidak), kendala aritas (tetap atau variabel), dan linearisation untuk penyimpanan (struktur pointer, string berpagar, notasi prefix/postfix, atau daftar anak eksplisit). Pohon bertipe (strongly-typed) menegakkan kendala sintaksis pada tingkat representasi, mencegah banyak keturunan tidak valid dan mengurangi kebutuhan perbaikan; tree tidak bertipe lebih fleksibel tetapi sering memerlukan pemeriksaan kelayakan tambahan atau decoder. Representasi memengaruhi lokalitas: penggantian subtree kecil dapat menimbulkan perubahan semantik besar ketika semantik node bersifat non-linier atau konteks-sensitif.

Kekhawatiran sentral pada tree encoding adalah bloat — pertumbuhan ukuran tree yang tidak terkendali tanpa peningkatan kecocokan yang sepadan. Bloat muncul dari daerah netral atau seleksi lemah dimana tree yang lebih besar tidak diberi penalti, dan menurunkan kinerja dengan meningkatkan biaya evaluasi serta mengurangi variabilitas efektif populasi. Tindakan pencegahan umum meliputi batas statis pada kedalaman/ukuran, tekanan parsimoni (penalti eksplisit ukuran atau kompleksitas dalam fitness), dan kontrol sadar-operator (membatasi ukuran keturunan pada crossover dan mutasi). Saat menggunakan kontrol pertumbuhan, diperlukan keseimbangan: pemangkasan terlalu agresif dapat menghilangkan variasi struktural berguna, sementara pengaturan longgar menyebabkan kehabisan sumber daya.

Operator variasi untuk tree harus menjaga keterbentukan tree. Operator standar termasuk subtree crossover (menukar subtree antar orang tua), point mutation (mengganti node atau subtree kecil dengan subtree yang dihasilkan acak), dan hoist mutation (mengganti sebuah tree dengan salah satu subtree-nya untuk mengurangi ukuran). Ada pula operator yang mempertahankan konteks dirancang untuk bahasa bertipe atau tata bahasa (pertukaran subtree terbatas, mutasi pandu-tata-bahasa) yang menjaga kebenaran sintaksis secara konstuktif. Desain operator harus selaras dengan semantik alfabet node: untuk tree ekspresi, mendorong rekombinasi yang menyadari komutatif/assosiatif atau penyederhanaan aljabar dapat meningkatkan produksi keturunan bermakna.

Encoding indirek dan berbasis tata bahasa sangat berguna bila fenotipe harus memenuhi kendala sintaksis atau semantik yang kaya. Dalam grammatical evolution dan grammar-guided GP, genotipe biasanya menyandikan derivasi atau urutan pilihan produksi, dan decoder deterministik memetakannya ke tree yang dijamin valid secara sintaksis. Encoding indirek ini dapat menghasilkan genotipe ringkas dan memungkinkan memasukkan pengetahuan domain, tetapi dapat mengaburkan sifat lokalitas operator dan membutuhkan desain decoder yang hati-hati untuk menghindari sampling fenotipe yang bias.

Rekomendasi praktis: tegakkan kelayakan sejak dini menggunakan pengetipan atau kendala tata bahasa bila domain memerlukan kebenaran sintaksis; gabungkan pencarian tree global dengan lintasan penyederhanaan lokal (constant folding, reduksi aljabar) untuk meningkatkan efisiensi evaluasi; gunakan strategi inisialisasi campuran (ramped half-and-half, grow/full) untuk menabur variasi ukuran dan bentuk tree; dan terapkan kontrol kompleksitas eksplisit (tekanan parsimoni, batas kedalaman, atau bias operator adaptif) untuk mengelola bloat. Akhirnya, validasi operator secara empiris pada instance representatif dan pantau ukuran tree, kedalaman, dan biaya evaluasi selama eksperimen untuk mendeteksi bloat atau perilaku patologis.



