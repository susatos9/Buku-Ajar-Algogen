\chapter{Genetic Algorithm Encoding}

\section{Introduction to Encoding}
Encoding (also called representation) is the process of transforming problem solutions into a form that genetic algorithms can manipulate. The choice of encoding significantly impacts GA performance and is one of the most critical design decisions.

\section{Requirements for Good Encoding}

\subsection{Completeness}
Every possible solution to the problem should have at least one corresponding representation in the genetic encoding.

\subsection{Soundness}
Every encoded string should correspond to a valid solution of the problem.

\subsection{Non-redundancy}
Each solution should have a unique representation (one-to-one mapping preferred).

\subsection{Locality}
Small changes in genotype should correspond to small changes in phenotype, ensuring smooth search.

\section{Binary Encoding}

Binary encoding is the most traditional and widely studied representation in genetic algorithms.

\subsection{Basic Binary Encoding}
Solutions are represented as fixed-length binary strings.

\textbf{Example}: Optimizing $f(x) = x^2$ where $x \in [0, 31]$
\begin{itemize}
    \item Use 5-bit representation
    \item $x = 13 \rightarrow 01101_2$
    \item $x = 27 \rightarrow 11011_2$
\end{itemize}

\subsection{Decoding Binary Strings}
For integer values in range $[x_{min}, x_{max}]$ using $l$ bits:

\begin{equation}
x = x_{min} + \frac{x_{max} - x_{min}}{2^l - 1} \times \text{binary\_value}
\end{equation}

\textbf{Example}: 5-bit string $10110_2 = 22_{10}$ for range $[0, 31]$:
\begin{equation}
x = 0 + \frac{31 - 0}{2^5 - 1} \times 22 = 0 + \frac{31}{31} \times 22 = 22
\end{equation}

\subsection{Multi-variable Binary Encoding}
For multiple variables, concatenate individual encodings:

\textbf{Example}: Two variables $x_1 \in [0, 15]$, $x_2 \in [0, 7]$
\begin{itemize}
    \item $x_1$: 4 bits
    \item $x_2$: 3 bits
    \item Combined: 7-bit string $x_1x_2$
    \item String $1011001$: $x_1 = 1011_2 = 11$, $x_2 = 001_2 = 1$
\end{itemize}

\subsection{Advantages of Binary Encoding}
\begin{itemize}
    \item Simple and easy to implement
    \item Well-studied theoretical foundation
    \item Standard crossover and mutation operators available
    \item Schema theory directly applicable
\end{itemize}

\subsection{Disadvantages of Binary Encoding}
\begin{itemize}
    \item Hamming cliff problem (adjacent values may have large Hamming distance)
    \item Fixed precision may be inadequate
    \item Long strings for high precision
    \item Epistasis between variables
\end{itemize}

\section{Gray Code Encoding}

Gray code addresses the Hamming cliff problem by ensuring adjacent values differ by only one bit.

\subsection{Binary to Gray Code Conversion}
\begin{algorithm}
\caption{Binary to Gray Code}
\begin{algorithmic}
\STATE $g_0 = b_0$ (most significant bit)
\FOR{$i = 1$ to $n-1$}
    \STATE $g_i = b_{i-1} \oplus b_i$ (XOR operation)
\ENDFOR
\end{algorithmic}
\end{algorithm}

\subsection{Gray Code to Binary Conversion}
\begin{algorithm}
\caption{Gray Code to Binary}
\begin{algorithmic}
\STATE $b_0 = g_0$
\FOR{$i = 1$ to $n-1$}
    \STATE $b_i = b_{i-1} \oplus g_i$
\ENDFOR
\end{algorithmic}
\end{algorithm}

\subsection{Example: 4-bit Gray Code}
\begin{table}[H]
\centering
\begin{tabular}{ccc}
\toprule
Decimal & Binary & Gray Code \\
\midrule
0 & 0000 & 0000 \\
1 & 0001 & 0001 \\
2 & 0010 & 0011 \\
3 & 0011 & 0010 \\
4 & 0100 & 0110 \\
5 & 0101 & 0111 \\
6 & 0110 & 0101 \\
7 & 0111 & 0100 \\
\bottomrule
\end{tabular}
\caption{Binary vs Gray Code Representation}
\end{table}

\section{Real-valued Encoding}

Real-valued encoding directly represents solutions as vectors of real numbers.

\subsection{Representation}
Individual: $\mathbf{x} = (x_1, x_2, \ldots, x_n)$ where $x_i \in \mathbb{R}$

\textbf{Example}: Function optimization $f(x_1, x_2) = x_1^2 + x_2^2$
Individual: $(2.5, -1.7)$

\subsection{Advantages}
\begin{itemize}
    \item Natural representation for continuous problems
    \item No precision limitations
    \item More compact than binary encoding
    \item Smooth fitness landscapes
\end{itemize}

\subsection{Disadvantages}
\begin{itemize}
    \item Requires specialized operators
    \item Loss of building block analysis
    \item Parameter tuning for operators
\end{itemize}

\subsection{Real-valued Crossover Operators}

\subsubsection{Arithmetic Crossover}
\begin{equation}
\begin{aligned}
\text{Offspring}_1 &= \alpha \times \text{Parent}_1 + (1-\alpha) \times \text{Parent}_2 \\
\text{Offspring}_2 &= (1-\alpha) \times \text{Parent}_1 + \alpha \times \text{Parent}_2
\end{aligned}
\end{equation}

where $\alpha \in [0, 1]$ is a random number.

\subsubsection{BLX-$\alpha$ Crossover}
For parents $x_1$ and $x_2$:
\begin{equation}
\text{Offspring} \sim U[x_{\min} - \alpha \cdot I, x_{\max} + \alpha \cdot I]
\end{equation}

where:
\begin{itemize}
    \item $x_{\min} = \min(x_1, x_2)$
    \item $x_{\max} = \max(x_1, x_2)$
    \item $I = x_{\max} - x_{\min}$
    \item $\alpha = 0.5$ typically
\end{itemize}

\subsection{Real-valued Mutation Operators}

\subsubsection{Gaussian Mutation}
\begin{equation}
x'_i = x_i + \mathcal{N}(0, \sigma^2)
\end{equation}

where $\mathcal{N}(0, \sigma^2)$ is Gaussian noise with mean 0 and variance $\sigma^2$.

\subsubsection{Non-uniform Mutation}
\begin{equation}
x'_i = \begin{cases}
x_i + \Delta(t, x_{\max} - x_i) & \text{if random bit is 0} \\
x_i - \Delta(t, x_i - x_{\min}) & \text{if random bit is 1}
\end{cases}
\end{equation}

where:
\begin{equation}
\Delta(t, y) = y \times \left(1 - r^{(1-t/T)^b}\right)
\end{equation}

\section{Integer Encoding}

For problems with integer variables.

\subsection{Representation}
Individual: $\mathbf{x} = (x_1, x_2, \ldots, x_n)$ where $x_i \in \mathbb{Z}$

\textbf{Example}: Knapsack problem with item quantities
Individual: $(3, 0, 2, 1, 4)$ represents taking 3 of item 1, 0 of item 2, etc.

\subsection{Integer Crossover}
\begin{itemize}
    \item Discrete uniform crossover
    \item Arithmetic crossover with rounding
    \item Two-point crossover
\end{itemize}

\subsection{Integer Mutation}
\begin{itemize}
    \item Random resetting: $x_i = \text{random integer in range}$
    \item Creep mutation: $x_i = x_i \pm \text{small integer}$
    \item Gaussian mutation with rounding
\end{itemize}

\section{Permutation Encoding}

For problems where solution is an ordering of elements.

\subsection{Representation}
Individual: Permutation of $\{1, 2, \ldots, n\}$

\textbf{Example}: Traveling Salesman Problem
Individual: $(3, 1, 4, 2, 5)$ represents visiting cities in order 3→1→4→2→5→3

\subsection{Permutation Crossover Operators}

\subsubsection{Order Crossover (OX)}
\begin{enumerate}
    \item Select random substring from parent 1
    \item Copy substring to offspring in same positions
    \item Fill remaining positions with elements from parent 2 in order they appear
\end{enumerate}

\textbf{Example}:
\begin{align}
\text{Parent 1:} &\quad (1, 2, 3, 4, 5, 6, 7, 8, 9) \\
\text{Parent 2:} &\quad (9, 3, 7, 8, 2, 6, 5, 1, 4) \\
\text{Selected:} &\quad (\_, \_, 3, 4, 5, 6, \_, \_, \_) \\
\text{Offspring:} &\quad (7, 8, 3, 4, 5, 6, 2, 1, 9)
\end{align}

\subsubsection{Partially Mapped Crossover (PMX)}
\begin{enumerate}
    \item Select two crossover points
    \item Exchange segments between parents
    \item Resolve conflicts using mapping relationship
\end{enumerate}

\subsubsection{Cycle Crossover (CX)}
Preserves position information from both parents by identifying cycles.

\subsection{Permutation Mutation Operators}

\subsubsection{Swap Mutation}
Randomly select two positions and swap their values.

\subsubsection{Insert Mutation}
Remove element from one position and insert at another position.

\subsubsection{Inversion Mutation}
Reverse order of elements in randomly selected substring.

\subsubsection{Scramble Mutation}
Randomly shuffle elements in selected substring.

\section{Tree Encoding}

For problems with hierarchical or tree structures.

\subsection{Applications}
\begin{itemize}
    \item Genetic programming
    \item Decision trees
    \item Parse trees
    \item Circuit design
\end{itemize}

\subsection{Representation}
Trees with:
\begin{itemize}
    \item Internal nodes: operators/functions
    \item Leaf nodes: terminals/variables
    \item Variable tree size and shape
\end{itemize}

\subsection{Tree Crossover}
Exchange randomly selected subtrees between parents.

\subsection{Tree Mutation}
\begin{itemize}
    \item Replace subtree with randomly generated subtree
    \item Change node value
    \item Grow or shrink tree
\end{itemize}

\section{Problem-specific Encodings}

\subsection{Graph Coloring}
Individual: $(c_1, c_2, \ldots, c_n)$ where $c_i$ is color of vertex $i$

\subsection{Job Scheduling}
Individual: Priority list or schedule representation

\subsection{Neural Network Weights}
Individual: Vector of real-valued connection weights

\section{Choosing the Right Encoding}

\subsection{Factors to Consider}
\begin{itemize}
    \item Problem domain and constraints
    \item Required precision
    \item Search space characteristics
    \item Available operators
    \item Computational efficiency
\end{itemize}

\subsection{Guidelines}
\begin{itemize}
    \item Use natural representation when possible
    \item Ensure all solutions are reachable
    \item Minimize epistasis between variables
    \item Consider hybrid approaches
    \item Test multiple encodings empirically
\end{itemize}

\section{Chapter Summary}

This chapter covered various encoding schemes for genetic algorithms. The choice of encoding is crucial and should match the problem characteristics. Binary encoding provides theoretical foundation, real-valued encoding suits continuous optimization, permutation encoding handles ordering problems, and specialized encodings address domain-specific requirements.

\section{Key Concepts}
\begin{itemize}
    \item Encoding requirements: completeness, soundness, non-redundancy
    \item Binary vs Gray code encoding
    \item Real-valued representation and operators
    \item Permutation encoding for ordering problems
    \item Tree encoding for hierarchical structures
    \item Problem-specific encoding considerations
\end{itemize}