\chapter{Genetic Algorithm Encoding}

\section{Introduction to Encoding}
Encoding (also called representation) is the process of transforming problem solutions into a form that genetic algorithms can manipulate~\cite{goldberg1989genetic, michalewicz1996genetic}. The choice of encoding significantly impacts GA performance and is one of the most critical design decisions.

\section{Requirements for Good Encoding}

\subsection{Completeness}
Every possible solution to the problem should have at least one corresponding representation in the genetic encoding.

\subsection{Soundness}
Every encoded string should correspond to a valid solution of the problem.

\subsection{Non-redundancy}
Each solution should have a unique representation (one-to-one mapping preferred).

\subsection{Locality}
Small changes in genotype should correspond to small changes in phenotype, ensuring smooth search.

\section{Binary Encoding}

Binary encoding is the most traditional and widely studied representation in genetic algorithms~\cite{holland1975adaptation, goldberg1989genetic}.

\subsection{Basic Binary Encoding}
Solutions are represented as fixed-length binary strings.

\textbf{Example}: Optimizing $f(x) = x^2$ where $x \in [0, 31]$
\begin{itemize}
    \item Use 5-bit representation
    \item $x = 13 \rightarrow 01101_2$
    \item $x = 27 \rightarrow 11011_2$
\end{itemize}

\subsection{Decoding Binary Strings}
For integer values in range $[x_{min}, x_{max}]$ using $l$ bits:

\begin{equation}
x = x_{min} + \frac{x_{max} - x_{min}}{2^l - 1} \times \text{binary\_value}
\end{equation}

\textbf{Example}: 5-bit string $10110_2 = 22_{10}$ for range $[0, 31]$:
\begin{equation}
x = 0 + \frac{31 - 0}{2^5 - 1} \times 22 = 0 + \frac{31}{31} \times 22 = 22
\end{equation}

\subsection{Multi-variable Binary Encoding}
For multiple variables, concatenate individual encodings:

\textbf{Example}: Two variables $x_1 \in [0, 15]$, $x_2 \in [0, 7]$
\begin{itemize}
    \item $x_1$: 4 bits
    \item $x_2$: 3 bits
    \item Combined: 7-bit string $x_1x_2$
    \item String $1011001$: $x_1 = 1011_2 = 11$, $x_2 = 001_2 = 1$
\end{itemize}

\subsection{Advantages of Binary Encoding}
\begin{itemize}
    \item Simple and easy to implement
    \item Well-studied theoretical foundation
    \item Standard crossover and mutation operators available
    \item Schema theory directly applicable
\end{itemize}

\subsection{Disadvantages of Binary Encoding}
\begin{itemize}
    \item Hamming cliff problem (adjacent values may have large Hamming distance)
    \item Fixed precision may be inadequate
    \item Long strings for high precision
    \item Epistasis between variables
    \item Not natural for many problems with real-valued features
    \item Often requires correction after genetic operations
\end{itemize}

\section{Overview of Encoding Types}

\subsection{Problem Identification and Formulation}
One thing to consider when using genetic algorithms is how we represent the data we are studying. Therefore, we must determine which encoding is most suitable for the problem we face. Like other search or learning methods, how encoding is done on candidate solutions is one of, if not the most important factor in the success of the genetic algorithm itself. Most genetic algorithm applications use bit strings with predetermined length and order. However, recently many experiments have been conducted with other types of encoding.

\subsection{What is Encoding}
Encoding is the process of representing individual genes. This process can be done with bits, numbers, trees, arrays, lists, or any other object. The encoding is primarily dependent on how the related object is solved. For example, encoding can be done with integers or real numbers.

\subsection{Encoding Type Categories}

\subsubsection{1. Binary Encoding}
Binary encoding, i.e., bit strings, is the simplest and most widely used type of encoding. Many renowned researchers use binary encoding in their problems, for example Holland, as in the Holland schema. Each chromosome is encoded as a binary string. Each bit in it represents a feature or characteristic of that solution. Binary encoding can store a lot of information with a minimal number of alleles (e.g., 0 or 1, compared to decimal which has many alleles).

Here are some examples of chromosomes with binary encoding:
\begin{itemize}
    \item Chromosome 1: 1 1 0 1 0 0 0 1 1 0 1 0
    \item Chromosome 2: 0 1 1 1 1 1 1 1 1 1 0 0
\end{itemize}

\begin{figure}[h]
\centering
\includegraphics[width=0.7\textwidth]{figures/buku_ajar_page_12.png}
\caption{Binary encoding examples and characteristics}
\label{fig:binary_encoding_example}
\end{figure}

On the other hand, this encoding is not natural and difficult to implement for most problems that generally have features in the form of real numbers, and corrections often have to be made after genetic operations are completed.

\subsubsection{2. Value Encoding}
Problems generally have complex values. Values like these are quite difficult to represent in binary form. This is where value encoding is used. Each chromosome is a string of values, where the value in each string itself can be anything related to the problem. This includes integers, letters, real numbers, and other values.

Here are some examples of chromosomes with value encoding:
\begin{itemize}
    \item Chromosome A: 1.2324, 5.3242, 0.4556, 2.3293, 2.4545
    \item Chromosome B: ABDJEIFJDHDIERJFDLDFLEGT
    \item Chromosome C: (back), (back), (right), (forward), (left)
\end{itemize}

\subsubsection{3. Permutation Encoding}
There are some special problems that do not look at chromosomes from their individual gene values. They look at the position of occurrence of each gene, as in ordering problems. Each gene can be an integer or real, representing numbers in a sequence.

Here are some examples of chromosomes with permutation encoding:
\begin{itemize}
    \item Chromosome A: 1 5 3 2 6 4 7 9 8
    \item Chromosome B: 8 5 6 7 2 3 1 4 9
\end{itemize}

\subsubsection{4. Tree Encoding}
Tree encoding is most often used in program expressions that constantly change in genetic programming. Each chromosome is a tree of an object such as a function or command from a programming language. Tree encoding has a number of advantages, one of which is enabling an open search space, because basically trees of any size can be formed through crossover and mutation.

However, this openness can be one of the weaknesses of this encoding method. The formed tree can become too large without being controlled, thus hindering the formation of more structured and hierarchical solution candidates. In addition, the resulting tree tends to be difficult to interpret and simplify due to its large size.

\begin{figure}[h]
\centering
\includegraphics[width=0.8\textwidth]{figures/buku_ajar_page_13.png}
\caption{Various encoding types: Value, Permutation, and Tree encoding}
\label{fig:encoding_types}
\end{figure}

\section{Gray Code Encoding}

Gray code addresses the Hamming cliff problem by ensuring adjacent values differ by only one bit~\cite{haupt2004practical, michalewicz1996genetic}.

\subsection{Binary to Gray Code Conversion}
\begin{algorithm}
\caption{Binary to Gray Code}
\begin{algorithmic}
\STATE $g_0 = b_0$ (most significant bit)
\FOR{$i = 1$ to $n-1$}
    \STATE $g_i = b_{i-1} \oplus b_i$ (XOR operation)
\ENDFOR
\end{algorithmic}
\end{algorithm}

\subsection{Gray Code to Binary Conversion}
\begin{algorithm}
\caption{Gray Code to Binary}
\begin{algorithmic}
\STATE $b_0 = g_0$
\FOR{$i = 1$ to $n-1$}
    \STATE $b_i = b_{i-1} \oplus g_i$
\ENDFOR
\end{algorithmic}
\end{algorithm}

\subsection{Example: 4-bit Gray Code}
\begin{table}[H]
\centering
\begin{tabular}{ccc}
\toprule
Decimal & Binary & Gray Code \\
\midrule
0 & 0000 & 0000 \\
1 & 0001 & 0001 \\
2 & 0010 & 0011 \\
3 & 0011 & 0010 \\
4 & 0100 & 0110 \\
5 & 0101 & 0111 \\
6 & 0110 & 0101 \\
7 & 0111 & 0100 \\
\bottomrule
\end{tabular}
\caption{Binary vs Gray Code Representation}
\end{table}

\section{Real-valued Encoding}

Real-valued encoding directly represents solutions as vectors of real numbers~\cite{back1996evolutionary, michalewicz1996genetic}.

\subsection{Representation}
Individual: $\mathbf{x} = (x_1, x_2, \ldots, x_n)$ where $x_i \in \mathbb{R}$

\textbf{Example}: Function optimization $f(x_1, x_2) = x_1^2 + x_2^2$
Individual: $(2.5, -1.7)$

\subsection{Advantages}
\begin{itemize}
    \item Natural representation for continuous problems
    \item No precision limitations
    \item More compact than binary encoding
    \item Smooth fitness landscapes
\end{itemize}

\subsection{Disadvantages}
\begin{itemize}
    \item Requires specialized operators
    \item Loss of building block analysis
    \item Parameter tuning for operators
\end{itemize}

\subsection{Real-valued Crossover Operators}

\subsubsection{Arithmetic Crossover}
\begin{equation}
\begin{aligned}
\text{Offspring}_1 &= \alpha \times \text{Parent}_1 + (1-\alpha) \times \text{Parent}_2 \\
\text{Offspring}_2 &= (1-\alpha) \times \text{Parent}_1 + \alpha \times \text{Parent}_2
\end{aligned}
\end{equation}

where $\alpha \in [0, 1]$ is a random number.

\subsubsection{BLX-$\alpha$ Crossover}
For parents $x_1$ and $x_2$:
\begin{equation}
\text{Offspring} \sim U[x_{\min} - \alpha \cdot I, x_{\max} + \alpha \cdot I]
\end{equation}

where:
\begin{itemize}
    \item $x_{\min} = \min(x_1, x_2)$
    \item $x_{\max} = \max(x_1, x_2)$
    \item $I = x_{\max} - x_{\min}$
    \item $\alpha = 0.5$ typically
\end{itemize}

\subsection{Real-valued Mutation Operators}

\subsubsection{Gaussian Mutation}
\begin{equation}
x'_i = x_i + \mathcal{N}(0, \sigma^2)
\end{equation}

where $\mathcal{N}(0, \sigma^2)$ is Gaussian noise with mean 0 and variance $\sigma^2$.

\subsubsection{Non-uniform Mutation}
\begin{equation}
x'_i = \begin{cases}
x_i + \Delta(t, x_{\max} - x_i) & \text{if random bit is 0} \\
x_i - \Delta(t, x_i - x_{\min}) & \text{if random bit is 1}
\end{cases}
\end{equation}

where:
\begin{equation}
\Delta(t, y) = y \times \left(1 - r^{(1-t/T)^b}\right)
\end{equation}

\section{Integer Encoding}

For problems with integer variables.

\subsection{Representation}
Individual: $\mathbf{x} = (x_1, x_2, \ldots, x_n)$ where $x_i \in \mathbb{Z}$

\textbf{Example}: Knapsack problem with item quantities
Individual: $(3, 0, 2, 1, 4)$ represents taking 3 of item 1, 0 of item 2, etc.

\subsection{Integer Crossover}
\begin{itemize}
    \item Discrete uniform crossover
    \item Arithmetic crossover with rounding
    \item Two-point crossover
\end{itemize}

\subsection{Integer Mutation}
\begin{itemize}
    \item Random resetting: $x_i = \text{random integer in range}$
    \item Creep mutation: $x_i = x_i \pm \text{small integer}$
    \item Gaussian mutation with rounding
\end{itemize}

\section{Permutation Encoding}

For problems where solution is an ordering of elements.

\subsection{Representation}
Individual: Permutation of $\{1, 2, \ldots, n\}$

\textbf{Example}: Traveling Salesman Problem
Individual: $(3, 1, 4, 2, 5)$ represents visiting cities in order 3→1→4→2→5→3

\subsection{Permutation Crossover Operators}

\subsubsection{Order Crossover (OX)}
\begin{enumerate}
    \item Select random substring from parent 1
    \item Copy substring to offspring in same positions
    \item Fill remaining positions with elements from parent 2 in order they appear
\end{enumerate}

\textbf{Example}:
\begin{align}
\text{Parent 1:} &\quad (1, 2, 3, 4, 5, 6, 7, 8, 9) \\
\text{Parent 2:} &\quad (9, 3, 7, 8, 2, 6, 5, 1, 4) \\
\text{Selected:} &\quad (\_, \_, 3, 4, 5, 6, \_, \_, \_) \\
\text{Offspring:} &\quad (7, 8, 3, 4, 5, 6, 2, 1, 9)
\end{align}

\subsubsection{Partially Mapped Crossover (PMX)}
\begin{enumerate}
    \item Select two crossover points
    \item Exchange segments between parents
    \item Resolve conflicts using mapping relationship
\end{enumerate}

\subsubsection{Cycle Crossover (CX)}
Preserves position information from both parents by identifying cycles.

\subsection{Permutation Mutation Operators}

\subsubsection{Swap Mutation}
Randomly select two positions and swap their values.

\subsubsection{Insert Mutation}
Remove element from one position and insert at another position.

\subsubsection{Inversion Mutation}
Reverse order of elements in randomly selected substring.

\subsubsection{Scramble Mutation}
Randomly shuffle elements in selected substring.

\section{Tree Encoding}

For problems with hierarchical or tree structures.

\subsection{Applications}
\begin{itemize}
    \item Genetic programming
    \item Decision trees
    \item Parse trees
    \item Circuit design
\end{itemize}

\subsection{Representation}
Trees with:
\begin{itemize}
    \item Internal nodes: operators/functions
    \item Leaf nodes: terminals/variables
    \item Variable tree size and shape
\end{itemize}

\subsection{Tree Crossover}
Exchange randomly selected subtrees between parents.

\subsection{Tree Mutation}
\begin{itemize}
    \item Replace subtree with randomly generated subtree
    \item Change node value
    \item Grow or shrink tree
\end{itemize}

\section{Problem-specific Encodings}

\subsection{Graph Coloring}
Individual: $(c_1, c_2, \ldots, c_n)$ where $c_i$ is color of vertex $i$

\subsection{Job Scheduling}
Individual: Priority list or schedule representation

\subsection{Neural Network Weights}
Individual: Vector of real-valued connection weights

\section{Choosing the Right Encoding}

\subsection{Factors to Consider}
\begin{itemize}
    \item Problem domain and constraints
    \item Required precision
    \item Search space characteristics
    \item Available operators
    \item Computational efficiency
\end{itemize}

\subsection{Guidelines}
\begin{itemize}
    \item Use natural representation when possible
    \item Ensure all solutions are reachable
    \item Minimize epistasis between variables
    \item Consider hybrid approaches
    \item Test multiple encodings empirically
\end{itemize}

\section{Chapter Summary}

This chapter covered various encoding schemes for genetic algorithms. The choice of encoding is crucial and should match the problem characteristics. Binary encoding provides theoretical foundation, real-valued encoding suits continuous optimization, permutation encoding handles ordering problems, and specialized encodings address domain-specific requirements.

\section{Key Concepts}
\begin{itemize}
    \item Encoding requirements: completeness, soundness, non-redundancy
    \item Binary vs Gray code encoding
    \item Real-valued representation and operators
    \item Permutation encoding for ordering problems
    \item Tree encoding for hierarchical structures
    \item Problem-specific encoding considerations
\end{itemize}